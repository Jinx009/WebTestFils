{"version":3,"sources":["NURBSSurface.js"],"names":[],"mappings":"AAAA;;;;;;;;AAQA,SACC,OADD,QAEO,gCAFP;AAGA,SAAS,UAAT,QAA2B,yBAA3B;;AAGA;;;;AAIA,IAAI,eAAe,UAAW,OAAX,EAAoB,OAApB,EAA6B,MAA7B,EAAqC,MAArC,CAA4C,qBAA5C,EAAmE,aAAnE,CAAiF,8BAAjF,EAAkH;;AAEpI,MAAK,OAAL,GAAe,OAAf;AACA,MAAK,OAAL,GAAe,OAAf;AACA,MAAK,MAAL,GAAc,MAAd;AACA,MAAK,MAAL,GAAc,MAAd;AACA,MAAK,aAAL,GAAqB,EAArB;;AAEA,KAAI,OAAO,OAAO,MAAP,GAAgB,OAAhB,GAA0B,CAArC;AACA,KAAI,OAAO,OAAO,MAAP,GAAgB,OAAhB,GAA0B,CAArC;;AAEA;AACA,MAAM,IAAI,IAAI,CAAd,EAAiB,IAAI,IAArB,EAA2B,EAAG,CAA9B,EAAkC;;AAEjC,OAAK,aAAL,CAAoB,CAApB,IAA0B,EAA1B;AACA,OAAM,IAAI,IAAI,CAAd,EAAiB,IAAI,IAArB,EAA2B,EAAG,CAA9B,EAAkC;;AAEjC,OAAI,QAAQ,cAAe,CAAf,EAAoB,CAApB,CAAZ;AACA,QAAK,aAAL,CAAoB,CAApB,EAAyB,CAAzB,IAA+B,IAAI,OAAJ,CAAa,MAAM,CAAnB,EAAsB,MAAM,CAA5B,EAA+B,MAAM,CAArC,EAAwC,MAAM,CAA9C,CAA/B;AAEA;AAED;AAED,CAxBD;;AA2BA,aAAa,SAAb,GAAyB;;AAExB,cAAa,YAFW;;AAIxB,WAAU,UAAW,EAAX,EAAe,EAAf,EAAmB,MAAnB,EAA4B;;AAErC,MAAI,IAAI,KAAK,MAAL,CAAa,CAAb,IAAmB,MAAO,KAAK,MAAL,CAAa,KAAK,MAAL,CAAY,MAAZ,GAAqB,CAAlC,IAAwC,KAAK,MAAL,CAAa,CAAb,CAA/C,CAA3B,CAFqC,CAEyD;AAC9F,MAAI,IAAI,KAAK,MAAL,CAAa,CAAb,IAAmB,MAAO,KAAK,MAAL,CAAa,KAAK,MAAL,CAAY,MAAZ,GAAqB,CAAlC,IAAwC,KAAK,MAAL,CAAa,CAAb,CAA/C,CAA3B,CAHqC,CAGyD;;AAE9F,aAAW,gBAAX,CAA6B,KAAK,OAAlC,EAA2C,KAAK,OAAhD,EAAyD,KAAK,MAA9D,EAAsE,KAAK,MAA3E,EAAmF,KAAK,aAAxF,EAAuG,CAAvG,EAA0G,CAA1G,EAA6G,MAA7G;AAEA;AAXuB,CAAzB;;AAcA,SAAS,YAAT","file":"NURBSSurface-compiled.js","sourcesContent":["/**\n * @author renej\n * NURBS surface object\n *\n * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.\n *\n **/\n\nimport {\n\tVector4\n} from \"../../../build/three.module.js\";\nimport { NURBSUtils } from \"../curves/NURBSUtils.js\";\n\n\n/**************************************************************\n *\tNURBS surface\n **************************************************************/\n\nvar NURBSSurface = function ( degree1, degree2, knots1, knots2 /* arrays of reals */, controlPoints /* array^2 of Vector(2|3|4) */ ) {\n\n\tthis.degree1 = degree1;\n\tthis.degree2 = degree2;\n\tthis.knots1 = knots1;\n\tthis.knots2 = knots2;\n\tthis.controlPoints = [];\n\n\tvar len1 = knots1.length - degree1 - 1;\n\tvar len2 = knots2.length - degree2 - 1;\n\n\t// ensure Vector4 for control points\n\tfor ( var i = 0; i < len1; ++ i ) {\n\n\t\tthis.controlPoints[ i ] = [];\n\t\tfor ( var j = 0; j < len2; ++ j ) {\n\n\t\t\tvar point = controlPoints[ i ][ j ];\n\t\t\tthis.controlPoints[ i ][ j ] = new Vector4( point.x, point.y, point.z, point.w );\n\n\t\t}\n\n\t}\n\n};\n\n\nNURBSSurface.prototype = {\n\n\tconstructor: NURBSSurface,\n\n\tgetPoint: function ( t1, t2, target ) {\n\n\t\tvar u = this.knots1[ 0 ] + t1 * ( this.knots1[ this.knots1.length - 1 ] - this.knots1[ 0 ] ); // linear mapping t1->u\n\t\tvar v = this.knots2[ 0 ] + t2 * ( this.knots2[ this.knots2.length - 1 ] - this.knots2[ 0 ] ); // linear mapping t2->u\n\n\t\tNURBSUtils.calcSurfacePoint( this.degree1, this.degree2, this.knots1, this.knots2, this.controlPoints, u, v, target );\n\n\t}\n};\n\nexport { NURBSSurface };\n"]}