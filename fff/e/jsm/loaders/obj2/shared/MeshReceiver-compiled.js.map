{"version":3,"sources":["MeshReceiver.js"],"names":[],"mappings":"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","file":"MeshReceiver-compiled.js","sourcesContent":["/**\n * @author Kai Salmen / https://kaisalmen.de\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\n\nimport {\n\tBufferAttribute,\n\tBufferGeometry,\n\tLineSegments,\n\tMesh,\n\tPoints\n} from \"../../../../../build/three.module.js\";\n\n\n/**\n *\n * @param {MaterialHandler} materialHandler\n * @constructor\n */\nconst MeshReceiver = function ( materialHandler ) {\n\n\tthis.logging = {\n\t\tenabled: false,\n\t\tdebug: false\n\t};\n\n\tthis.callbacks = {\n\t\tonProgress: null,\n\t\tonMeshAlter: null\n\t};\n\tthis.materialHandler = materialHandler;\n\n};\n\nMeshReceiver.prototype = {\n\n\tconstructor: MeshReceiver,\n\n\t/**\n\t * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n\t *\n\t * @param {boolean} enabled True or false.\n\t * @param {boolean} debug True or false.\n\t */\n\tsetLogging:\tfunction ( enabled, debug ) {\n\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\n\t},\n\n\t/**\n\t *\n\t * @param {Function} onProgress\n\t * @param {Function} onMeshAlter\n\t * @private\n\t */\n\t_setCallbacks: function ( onProgress, onMeshAlter ) {\n\n\t\tif ( onProgress !== null && onProgress !== undefined && onProgress instanceof Function ) {\n\n\t\t\tthis.callbacks.onProgress = onProgress;\n\n\t\t}\n\t\tif ( onMeshAlter !== null && onMeshAlter !== undefined && onMeshAlter instanceof Function ) {\n\n\t\t\tthis.callbacks.onMeshAlter = onMeshAlter;\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Builds one or multiple meshes from the data described in the payload (buffers, params, material info).\n\t *\n\t * @param {Object} meshPayload Raw mesh description (buffers, params, materials) used to build one to many meshes.\n\t * @returns {Mesh[]} mesh Array of {@link Mesh}\n\t */\n\tbuildMeshes: function ( meshPayload ) {\n\n\t\tlet meshName = meshPayload.params.meshName;\n\t\tlet buffers = meshPayload.buffers;\n\n\t\tlet bufferGeometry = new BufferGeometry();\n\t\tif ( buffers.vertices !== undefined && buffers.vertices !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( buffers.vertices ), 3 ) );\n\n\t\t}\n\t\tif ( buffers.indices !== undefined && buffers.indices !== null ) {\n\n\t\t\tbufferGeometry.setIndex( new BufferAttribute( new Uint32Array( buffers.indices ), 1 ) );\n\n\t\t}\n\t\tif ( buffers.colors !== undefined && buffers.colors !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'color', new BufferAttribute( new Float32Array( buffers.colors ), 3 ) );\n\n\t\t}\n\t\tif ( buffers.normals !== undefined && buffers.normals !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'normal', new BufferAttribute( new Float32Array( buffers.normals ), 3 ) );\n\n\t\t} else {\n\n\t\t\tbufferGeometry.computeVertexNormals();\n\n\t\t}\n\t\tif ( buffers.uvs !== undefined && buffers.uvs !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'uv', new BufferAttribute( new Float32Array( buffers.uvs ), 2 ) );\n\n\t\t}\n\t\tif ( buffers.skinIndex !== undefined && buffers.skinIndex !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'skinIndex', new BufferAttribute( new Uint16Array( buffers.skinIndex ), 4 ) );\n\n\t\t}\n\t\tif ( buffers.skinWeight !== undefined && buffers.skinWeight !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'skinWeight', new BufferAttribute( new Float32Array( buffers.skinWeight ), 4 ) );\n\n\t\t}\n\n\t\tlet material, materialName, key;\n\t\tlet materialNames = meshPayload.materials.materialNames;\n\t\tlet createMultiMaterial = meshPayload.materials.multiMaterial;\n\t\tlet multiMaterials = [];\n\t\tfor ( key in materialNames ) {\n\n\t\t\tmaterialName = materialNames[ key ];\n\t\t\tmaterial = this.materialHandler.getMaterial( materialName );\n\t\t\tif ( createMultiMaterial ) multiMaterials.push( material );\n\n\t\t}\n\t\tif ( createMultiMaterial ) {\n\n\t\t\tmaterial = multiMaterials;\n\t\t\tlet materialGroups = meshPayload.materials.materialGroups;\n\t\t\tlet materialGroup;\n\t\t\tfor ( key in materialGroups ) {\n\n\t\t\t\tmaterialGroup = materialGroups[ key ];\n\t\t\t\tbufferGeometry.addGroup( materialGroup.start, materialGroup.count, materialGroup.index );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet meshes = [];\n\t\tlet mesh;\n\t\tlet callbackOnMeshAlterResult;\n\t\tlet useOrgMesh = true;\n\t\tlet geometryType = meshPayload.geometryType === null ? 0 : meshPayload.geometryType;\n\n\t\tif ( this.callbacks.onMeshAlter ) {\n\n\t\t\tcallbackOnMeshAlterResult = this.callbacks.onMeshAlter(\n\t\t\t\t{\n\t\t\t\t\tdetail: {\n\t\t\t\t\t\tmeshName: meshName,\n\t\t\t\t\t\tbufferGeometry: bufferGeometry,\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tgeometryType: geometryType\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\t// here LoadedMeshUserOverride is required to be provided by the callback used to alter the results\n\t\tif ( callbackOnMeshAlterResult ) {\n\n\t\t\tif ( callbackOnMeshAlterResult.isDisregardMesh() ) {\n\n\t\t\t\tuseOrgMesh = false;\n\n\t\t\t} else if ( callbackOnMeshAlterResult.providesAlteredMeshes() ) {\n\n\t\t\t\tfor ( let i in callbackOnMeshAlterResult.meshes ) {\n\n\t\t\t\t\tmeshes.push( callbackOnMeshAlterResult.meshes[ i ] );\n\n\t\t\t\t}\n\t\t\t\tuseOrgMesh = false;\n\n\t\t\t}\n\n\t\t}\n\t\tif ( useOrgMesh ) {\n\n\t\t\tif ( meshPayload.computeBoundingSphere ) bufferGeometry.computeBoundingSphere();\n\t\t\tif ( geometryType === 0 ) {\n\n\t\t\t\tmesh = new Mesh( bufferGeometry, material );\n\n\t\t\t} else if ( geometryType === 1 ) {\n\n\t\t\t\tmesh = new LineSegments( bufferGeometry, material );\n\n\t\t\t} else {\n\n\t\t\t\tmesh = new Points( bufferGeometry, material );\n\n\t\t\t}\n\t\t\tmesh.name = meshName;\n\t\t\tmeshes.push( mesh );\n\n\t\t}\n\n\t\tlet progressMessage = meshPayload.params.meshName;\n\t\tif ( meshes.length > 0 ) {\n\n\t\t\tlet meshNames = [];\n\t\t\tfor ( let i in meshes ) {\n\n\t\t\t\tmesh = meshes[ i ];\n\t\t\t\tmeshNames[ i ] = mesh.name;\n\n\t\t\t}\n\t\t\tprogressMessage += ': Adding mesh(es) (' + meshNames.length + ': ' + meshNames + ') from input mesh: ' + meshName;\n\t\t\tprogressMessage += ' (' + ( meshPayload.progress.numericalValue * 100 ).toFixed( 2 ) + '%)';\n\n\t\t} else {\n\n\t\t\tprogressMessage += ': Not adding mesh: ' + meshName;\n\t\t\tprogressMessage += ' (' + ( meshPayload.progress.numericalValue * 100 ).toFixed( 2 ) + '%)';\n\n\t\t}\n\t\tif ( this.callbacks.onProgress ) {\n\n\t\t\tthis.callbacks.onProgress( 'progress', progressMessage, meshPayload.progress.numericalValue );\n\n\t\t}\n\n\t\treturn meshes;\n\n\t}\n\n};\n\n/**\n * Object to return by callback onMeshAlter. Used to disregard a certain mesh or to return one to many meshes.\n * @class\n *\n * @param {boolean} disregardMesh=false Tell implementation to completely disregard this mesh\n * @param {boolean} disregardMesh=false Tell implementation that mesh(es) have been altered or added\n */\nconst LoadedMeshUserOverride = function ( disregardMesh, alteredMesh ) {\n\n\tthis.disregardMesh = disregardMesh === true;\n\tthis.alteredMesh = alteredMesh === true;\n\tthis.meshes = [];\n\n};\n\n\nLoadedMeshUserOverride.prototype = {\n\n\tconstructor: LoadedMeshUserOverride,\n\n\t/**\n\t * Add a mesh created within callback.\n\t *\n\t * @param {Mesh} mesh\n\t */\n\taddMesh: function ( mesh ) {\n\n\t\tthis.meshes.push( mesh );\n\t\tthis.alteredMesh = true;\n\n\t},\n\n\t/**\n\t * Answers if mesh shall be disregarded completely.\n\t *\n\t * @returns {boolean}\n\t */\n\tisDisregardMesh: function () {\n\n\t\treturn this.disregardMesh;\n\n\t},\n\n\t/**\n\t * Answers if new mesh(es) were created.\n\t *\n\t * @returns {boolean}\n\t */\n\tprovidesAlteredMeshes: function () {\n\n\t\treturn this.alteredMesh;\n\n\t}\n};\n\nexport {\n\tMeshReceiver,\n\tLoadedMeshUserOverride\n};\n"]}