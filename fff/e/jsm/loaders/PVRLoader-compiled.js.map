{"version":3,"sources":["PVRLoader.js"],"names":[],"mappings":"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","file":"PVRLoader-compiled.js","sourcesContent":["/*\n *\t PVRLoader\n *   Author: pierre lepers\n *   Date: 17/09/2014 11:09\n *\n *\t PVR v2 (legacy) parser\n *   TODO : Add Support for PVR v3 format\n *   TODO : implement loadMipmaps option\n */\n\nimport {\n\tCompressedTextureLoader,\n\tRGBA_PVRTC_2BPPV1_Format,\n\tRGBA_PVRTC_4BPPV1_Format,\n\tRGB_PVRTC_2BPPV1_Format,\n\tRGB_PVRTC_4BPPV1_Format\n} from \"../../../build/three.module.js\";\n\nvar PVRLoader = function ( manager ) {\n\n\tCompressedTextureLoader.call( this, manager );\n\n};\n\nPVRLoader.prototype = Object.assign( Object.create( CompressedTextureLoader.prototype ), {\n\n\tconstructor: PVRLoader,\n\n\tparse: function ( buffer, loadMipmaps ) {\n\n\t\tvar headerLengthInt = 13;\n\t\tvar header = new Uint32Array( buffer, 0, headerLengthInt );\n\n\t\tvar pvrDatas = {\n\t\t\tbuffer: buffer,\n\t\t\theader: header,\n\t\t\tloadMipmaps: loadMipmaps\n\t\t};\n\n\t\tif ( header[ 0 ] === 0x03525650 ) {\n\n\t\t\t// PVR v3\n\n\t\t\treturn PVRLoader._parseV3( pvrDatas );\n\n\t\t} else if ( header[ 11 ] === 0x21525650 ) {\n\n\t\t\t// PVR v2\n\n\t\t\treturn PVRLoader._parseV2( pvrDatas );\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.PVRLoader: Unknown PVR format.' );\n\n\t\t}\n\n\t}\n\n} );\n\nPVRLoader._parseV3 = function ( pvrDatas ) {\n\n\tvar header = pvrDatas.header;\n\tvar bpp, format;\n\n\n\tvar metaLen = header[ 12 ],\n\t\tpixelFormat = header[ 2 ],\n\t\theight = header[ 6 ],\n\t\twidth = header[ 7 ],\n\t\t// numSurfs = header[ 9 ],\n\t\tnumFaces = header[ 10 ],\n\t\tnumMipmaps = header[ 11 ];\n\n\tswitch ( pixelFormat ) {\n\n\t\tcase 0 : // PVRTC 2bpp RGB\n\t\t\tbpp = 2;\n\t\t\tformat = RGB_PVRTC_2BPPV1_Format;\n\t\t\tbreak;\n\n\t\tcase 1 : // PVRTC 2bpp RGBA\n\t\t\tbpp = 2;\n\t\t\tformat = RGBA_PVRTC_2BPPV1_Format;\n\t\t\tbreak;\n\n\t\tcase 2 : // PVRTC 4bpp RGB\n\t\t\tbpp = 4;\n\t\t\tformat = RGB_PVRTC_4BPPV1_Format;\n\t\t\tbreak;\n\n\t\tcase 3 : // PVRTC 4bpp RGBA\n\t\t\tbpp = 4;\n\t\t\tformat = RGBA_PVRTC_4BPPV1_Format;\n\t\t\tbreak;\n\n\t\tdefault :\n\t\t\tconsole.error( 'THREE.PVRLoader: Unsupported PVR format:', pixelFormat );\n\n\t}\n\n\tpvrDatas.dataPtr = 52 + metaLen;\n\tpvrDatas.bpp = bpp;\n\tpvrDatas.format = format;\n\tpvrDatas.width = width;\n\tpvrDatas.height = height;\n\tpvrDatas.numSurfaces = numFaces;\n\tpvrDatas.numMipmaps = numMipmaps;\n\tpvrDatas.isCubemap \t= ( numFaces === 6 );\n\n\treturn PVRLoader._extract( pvrDatas );\n\n};\n\nPVRLoader._parseV2 = function ( pvrDatas ) {\n\n\tvar header = pvrDatas.header;\n\n\tvar headerLength = header[ 0 ],\n\t\theight = header[ 1 ],\n\t\twidth = header[ 2 ],\n\t\tnumMipmaps = header[ 3 ],\n\t\tflags = header[ 4 ],\n\t\t// dataLength = header[ 5 ],\n\t\t// bpp =  header[ 6 ],\n\t\t// bitmaskRed = header[ 7 ],\n\t\t// bitmaskGreen = header[ 8 ],\n\t\t// bitmaskBlue = header[ 9 ],\n\t\tbitmaskAlpha = header[ 10 ],\n\t\t// pvrTag = header[ 11 ],\n\t\tnumSurfs = header[ 12 ];\n\n\n\tvar TYPE_MASK = 0xff;\n\tvar PVRTC_2 = 24,\n\t\tPVRTC_4 = 25;\n\n\tvar formatFlags = flags & TYPE_MASK;\n\n\tvar bpp, format;\n\tvar _hasAlpha = bitmaskAlpha > 0;\n\n\tif ( formatFlags === PVRTC_4 ) {\n\n\t\tformat = _hasAlpha ? RGBA_PVRTC_4BPPV1_Format : RGB_PVRTC_4BPPV1_Format;\n\t\tbpp = 4;\n\n\t} else if ( formatFlags === PVRTC_2 ) {\n\n\t\tformat = _hasAlpha ? RGBA_PVRTC_2BPPV1_Format : RGB_PVRTC_2BPPV1_Format;\n\t\tbpp = 2;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.PVRLoader: Unknown PVR format:', formatFlags );\n\n\t}\n\n\tpvrDatas.dataPtr = headerLength;\n\tpvrDatas.bpp = bpp;\n\tpvrDatas.format = format;\n\tpvrDatas.width = width;\n\tpvrDatas.height = height;\n\tpvrDatas.numSurfaces = numSurfs;\n\tpvrDatas.numMipmaps = numMipmaps + 1;\n\n\t// guess cubemap type seems tricky in v2\n\t// it juste a pvr containing 6 surface (no explicit cubemap type)\n\tpvrDatas.isCubemap \t= ( numSurfs === 6 );\n\n\treturn PVRLoader._extract( pvrDatas );\n\n};\n\n\nPVRLoader._extract = function ( pvrDatas ) {\n\n\tvar pvr = {\n\t\tmipmaps: [],\n\t\twidth: pvrDatas.width,\n\t\theight: pvrDatas.height,\n\t\tformat: pvrDatas.format,\n\t\tmipmapCount: pvrDatas.numMipmaps,\n\t\tisCubemap: pvrDatas.isCubemap\n\t};\n\n\tvar buffer = pvrDatas.buffer;\n\n\tvar dataOffset = pvrDatas.dataPtr,\n\t\tbpp = pvrDatas.bpp,\n\t\tnumSurfs = pvrDatas.numSurfaces,\n\t\tdataSize = 0,\n\t\tblockSize = 0,\n\t\tblockWidth = 0,\n\t\tblockHeight = 0,\n\t\twidthBlocks = 0,\n\t\theightBlocks = 0;\n\n\tif ( bpp === 2 ) {\n\n\t\tblockWidth = 8;\n\t\tblockHeight = 4;\n\n\t} else {\n\n\t\tblockWidth = 4;\n\t\tblockHeight = 4;\n\n\t}\n\n\tblockSize = ( blockWidth * blockHeight ) * bpp / 8;\n\n\tpvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;\n\n\tvar mipLevel = 0;\n\n\twhile ( mipLevel < pvrDatas.numMipmaps ) {\n\n\t\tvar sWidth = pvrDatas.width >> mipLevel,\n\t\t\tsHeight = pvrDatas.height >> mipLevel;\n\n\t\twidthBlocks = sWidth / blockWidth;\n\t\theightBlocks = sHeight / blockHeight;\n\n\t\t// Clamp to minimum number of blocks\n\t\tif ( widthBlocks < 2 ) widthBlocks = 2;\n\t\tif ( heightBlocks < 2 ) heightBlocks = 2;\n\n\t\tdataSize = widthBlocks * heightBlocks * blockSize;\n\n\t\tfor ( var surfIndex = 0; surfIndex < numSurfs; surfIndex ++ ) {\n\n\t\t\tvar byteArray = new Uint8Array( buffer, dataOffset, dataSize );\n\n\t\t\tvar mipmap = {\n\t\t\t\tdata: byteArray,\n\t\t\t\twidth: sWidth,\n\t\t\t\theight: sHeight\n\t\t\t};\n\n\t\t\tpvr.mipmaps[ surfIndex * pvrDatas.numMipmaps + mipLevel ] = mipmap;\n\n\t\t\tdataOffset += dataSize;\n\n\t\t}\n\n\t\tmipLevel ++;\n\n\t}\n\n\treturn pvr;\n\n};\n\nexport { PVRLoader };\n"]}