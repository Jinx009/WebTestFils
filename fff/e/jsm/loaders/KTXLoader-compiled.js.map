{"version":3,"sources":["KTXLoader.js"],"names":[],"mappings":"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","file":"KTXLoader-compiled.js","sourcesContent":["/**\n * @author amakaseev / https://github.com/amakaseev\n *\n * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\n * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\n *\n * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Tools/babylon.khronosTextureContainer.ts\n */\n\nimport {\n\tCompressedTextureLoader\n} from \"../../../build/three.module.js\";\n\n\nvar KTXLoader = function ( manager ) {\n\n\tCompressedTextureLoader.call( this, manager );\n\n};\n\nKTXLoader.prototype = Object.assign( Object.create( CompressedTextureLoader.prototype ), {\n\n\tconstructor: KTXLoader,\n\n\tparse: function ( buffer, loadMipmaps ) {\n\n\t\tvar ktx = new KhronosTextureContainer( buffer, 1 );\n\n\t\treturn {\n\t\t\tmipmaps: ktx.mipmaps( loadMipmaps ),\n\t\t\twidth: ktx.pixelWidth,\n\t\t\theight: ktx.pixelHeight,\n\t\t\tformat: ktx.glInternalFormat,\n\t\t\tisCubemap: ktx.numberOfFaces === 6,\n\t\t\tmipmapCount: ktx.numberOfMipmapLevels\n\t\t};\n\n\t}\n\n} );\n\nvar KhronosTextureContainer = ( function () {\n\n\t/**\n\t * @param {ArrayBuffer} arrayBuffer- contents of the KTX container file\n\t * @param {number} facesExpected- should be either 1 or 6, based whether a cube texture or or\n\t * @param {boolean} threeDExpected- provision for indicating that data should be a 3D texture, not implemented\n\t * @param {boolean} textureArrayExpected- provision for indicating that data should be a texture array, not implemented\n\t */\n\tfunction KhronosTextureContainer( arrayBuffer, facesExpected /*, threeDExpected, textureArrayExpected */ ) {\n\n\t\tthis.arrayBuffer = arrayBuffer;\n\n\t\t// Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:\n\t\t// '´', 'K', 'T', 'X', ' ', '1', '1', 'ª', '\\r', '\\n', '\\x1A', '\\n'\n\t\t// 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A\n\t\tvar identifier = new Uint8Array( this.arrayBuffer, 0, 12 );\n\t\tif ( identifier[ 0 ] !== 0xAB ||\n\t\t\tidentifier[ 1 ] !== 0x4B ||\n\t\t\tidentifier[ 2 ] !== 0x54 ||\n\t\t\tidentifier[ 3 ] !== 0x58 ||\n\t\t\tidentifier[ 4 ] !== 0x20 ||\n\t\t\tidentifier[ 5 ] !== 0x31 ||\n\t\t\tidentifier[ 6 ] !== 0x31 ||\n\t\t\tidentifier[ 7 ] !== 0xBB ||\n\t\t\tidentifier[ 8 ] !== 0x0D ||\n\t\t\tidentifier[ 9 ] !== 0x0A ||\n\t\t\tidentifier[ 10 ] !== 0x1A ||\n\t\t\tidentifier[ 11 ] !== 0x0A ) {\n\n\t\t\tconsole.error( 'texture missing KTX identifier' );\n\t\t\treturn;\n\n\t\t}\n\n\t\t// load the reset of the header in native 32 bit uint\n\t\tvar dataSize = Uint32Array.BYTES_PER_ELEMENT;\n\t\tvar headerDataView = new DataView( this.arrayBuffer, 12, 13 * dataSize );\n\t\tvar endianness = headerDataView.getUint32( 0, true );\n\t\tvar littleEndian = endianness === 0x04030201;\n\n\t\tthis.glType = headerDataView.getUint32( 1 * dataSize, littleEndian ); // must be 0 for compressed textures\n\t\tthis.glTypeSize = headerDataView.getUint32( 2 * dataSize, littleEndian ); // must be 1 for compressed textures\n\t\tthis.glFormat = headerDataView.getUint32( 3 * dataSize, littleEndian ); // must be 0 for compressed textures\n\t\tthis.glInternalFormat = headerDataView.getUint32( 4 * dataSize, littleEndian ); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\n\t\tthis.glBaseInternalFormat = headerDataView.getUint32( 5 * dataSize, littleEndian ); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\n\t\tthis.pixelWidth = headerDataView.getUint32( 6 * dataSize, littleEndian ); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\n\t\tthis.pixelHeight = headerDataView.getUint32( 7 * dataSize, littleEndian ); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\n\t\tthis.pixelDepth = headerDataView.getUint32( 8 * dataSize, littleEndian ); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\n\t\tthis.numberOfArrayElements = headerDataView.getUint32( 9 * dataSize, littleEndian ); // used for texture arrays\n\t\tthis.numberOfFaces = headerDataView.getUint32( 10 * dataSize, littleEndian ); // used for cubemap textures, should either be 1 or 6\n\t\tthis.numberOfMipmapLevels = headerDataView.getUint32( 11 * dataSize, littleEndian ); // number of levels; disregard possibility of 0 for compressed textures\n\t\tthis.bytesOfKeyValueData = headerDataView.getUint32( 12 * dataSize, littleEndian ); // the amount of space after the header for meta-data\n\n\t\t// Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\n\t\tif ( this.glType !== 0 ) {\n\n\t\t\tconsole.warn( 'only compressed formats currently supported' );\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\n\t\t\tthis.numberOfMipmapLevels = Math.max( 1, this.numberOfMipmapLevels );\n\n\t\t}\n\t\tif ( this.pixelHeight === 0 || this.pixelDepth !== 0 ) {\n\n\t\t\tconsole.warn( 'only 2D textures currently supported' );\n\t\t\treturn;\n\n\t\t}\n\t\tif ( this.numberOfArrayElements !== 0 ) {\n\n\t\t\tconsole.warn( 'texture arrays not currently supported' );\n\t\t\treturn;\n\n\t\t}\n\t\tif ( this.numberOfFaces !== facesExpected ) {\n\n\t\t\tconsole.warn( 'number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces );\n\t\t\treturn;\n\n\t\t}\n\t\t// we now have a completely validated file, so could use existence of loadType as success\n\t\t// would need to make this more elaborate & adjust checks above to support more than one load type\n\t\tthis.loadType = KhronosTextureContainer.COMPRESSED_2D;\n\n\t}\n\n\t// return mipmaps for js\n\tKhronosTextureContainer.prototype.mipmaps = function ( loadMipmaps ) {\n\n\t\tvar mipmaps = [];\n\n\t\t// initialize width & height for level 1\n\t\tvar dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;\n\t\tvar width = this.pixelWidth;\n\t\tvar height = this.pixelHeight;\n\t\tvar mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;\n\n\t\tfor ( var level = 0; level < mipmapCount; level ++ ) {\n\n\t\t\tvar imageSize = new Int32Array( this.arrayBuffer, dataOffset, 1 )[ 0 ]; // size per face, since not supporting array cubemaps\n\t\t\tdataOffset += 4; // size of the image + 4 for the imageSize field\n\n\t\t\tfor ( var face = 0; face < this.numberOfFaces; face ++ ) {\n\n\t\t\t\tvar byteArray = new Uint8Array( this.arrayBuffer, dataOffset, imageSize );\n\n\t\t\t\tmipmaps.push( { \"data\": byteArray, \"width\": width, \"height\": height } );\n\n\t\t\t\tdataOffset += imageSize;\n\t\t\t\tdataOffset += 3 - ( ( imageSize + 3 ) % 4 ); // add padding for odd sized image\n\n\t\t\t}\n\t\t\twidth = Math.max( 1.0, width * 0.5 );\n\t\t\theight = Math.max( 1.0, height * 0.5 );\n\n\t\t}\n\n\t\treturn mipmaps;\n\n\t};\n\n\tKhronosTextureContainer.HEADER_LEN = 12 + ( 13 * 4 ); // identifier + header elements (not including key value meta-data pairs)\n\t// load types\n\tKhronosTextureContainer.COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\n\tKhronosTextureContainer.COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\n\tKhronosTextureContainer.TEX_2D = 2; // uses a gl.texImage2D()\n\tKhronosTextureContainer.TEX_3D = 3; // uses a gl.texImage3D()\n\n\treturn KhronosTextureContainer;\n\n}() );\n\nexport { KTXLoader };\n"]}