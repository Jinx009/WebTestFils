{"version":3,"sources":["Reflector.js"],"names":[],"mappings":"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","file":"Reflector-compiled.js","sourcesContent":["console.warn( \"THREE.Reflector: As part of the transition to ES6 Modules, the files in 'examples/js' were deprecated in May 2020 (r117) and will be deleted in December 2020 (r124). You can find more information about developing using ES6 Modules in https://threejs.org/docs/#manual/en/introduction/Installation.\" );\n\nTHREE.Reflector = function ( geometry, options ) {\n\n\tTHREE.Mesh.call( this, geometry );\n\n\tthis.type = 'Reflector';\n\n\tvar scope = this;\n\n\toptions = options || {};\n\n\tvar color = ( options.color !== undefined ) ? new THREE.Color( options.color ) : new THREE.Color( 0x7F7F7F );\n\tvar textureWidth = options.textureWidth || 512;\n\tvar textureHeight = options.textureHeight || 512;\n\tvar clipBias = options.clipBias || 0;\n\tvar shader = options.shader || THREE.Reflector.ReflectorShader;\n\n\t//\n\n\tvar reflectorPlane = new THREE.Plane();\n\tvar normal = new THREE.Vector3();\n\tvar reflectorWorldPosition = new THREE.Vector3();\n\tvar cameraWorldPosition = new THREE.Vector3();\n\tvar rotationMatrix = new THREE.Matrix4();\n\tvar lookAtPosition = new THREE.Vector3( 0, 0, - 1 );\n\tvar clipPlane = new THREE.Vector4();\n\n\tvar view = new THREE.Vector3();\n\tvar target = new THREE.Vector3();\n\tvar q = new THREE.Vector4();\n\n\tvar textureMatrix = new THREE.Matrix4();\n\tvar virtualCamera = new THREE.PerspectiveCamera();\n\n\tvar parameters = {\n\t\tminFilter: THREE.LinearFilter,\n\t\tmagFilter: THREE.LinearFilter,\n\t\tformat: THREE.RGBFormat\n\t};\n\n\tvar renderTarget = new THREE.WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\tif ( ! THREE.MathUtils.isPowerOfTwo( textureWidth ) || ! THREE.MathUtils.isPowerOfTwo( textureHeight ) ) {\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t}\n\n\tvar material = new THREE.ShaderMaterial( {\n\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\n\t\tfragmentShader: shader.fragmentShader,\n\t\tvertexShader: shader.vertexShader\n\t} );\n\n\tmaterial.uniforms[ \"tDiffuse\" ].value = renderTarget.texture;\n\tmaterial.uniforms[ \"color\" ].value = color;\n\tmaterial.uniforms[ \"textureMatrix\" ].value = textureMatrix;\n\n\tthis.material = material;\n\n\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\tnormal.set( 0, 0, 1 );\n\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t// Avoid rendering when reflector is facing away\n\n\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\tview.reflect( normal ).negate();\n\t\tview.add( reflectorWorldPosition );\n\n\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\ttarget.reflect( normal ).negate();\n\t\ttarget.add( reflectorWorldPosition );\n\n\t\tvirtualCamera.position.copy( view );\n\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\tvirtualCamera.up.reflect( normal );\n\t\tvirtualCamera.lookAt( target );\n\n\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\tvirtualCamera.updateMatrixWorld();\n\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t// Update the texture matrix\n\t\ttextureMatrix.set(\n\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\n\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\n\n\t\tvar projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\tq.z = - 1.0;\n\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t// Calculate the scaled plane vector\n\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t// Replacing the third row of the projection matrix\n\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t// Render\n\n\t\trenderTarget.texture.encoding = renderer.outputEncoding;\n\n\t\tscope.visible = false;\n\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\tvar currentXrEnabled = renderer.xr.enabled;\n\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\trenderer.setRenderTarget( renderTarget );\n\n\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\trenderer.render( scene, virtualCamera );\n\n\t\trenderer.xr.enabled = currentXrEnabled;\n\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t// Restore viewport\n\n\t\tvar viewport = camera.viewport;\n\n\t\tif ( viewport !== undefined ) {\n\n\t\t\trenderer.state.viewport( viewport );\n\n\t\t}\n\n\t\tscope.visible = true;\n\n\t};\n\n\tthis.getRenderTarget = function () {\n\n\t\treturn renderTarget;\n\n\t};\n\n};\n\nTHREE.Reflector.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.Reflector.prototype.constructor = THREE.Reflector;\n\nTHREE.Reflector.ReflectorShader = {\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: [\n\t\t'uniform mat4 textureMatrix;',\n\t\t'varying vec4 vUv;',\n\n\t\t'void main() {',\n\n\t\t'\tvUv = textureMatrix * vec4( position, 1.0 );',\n\n\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n\t\t'}'\n\t].join( '\\n' ),\n\n\tfragmentShader: [\n\t\t'uniform vec3 color;',\n\t\t'uniform sampler2D tDiffuse;',\n\t\t'varying vec4 vUv;',\n\n\t\t'float blendOverlay( float base, float blend ) {',\n\n\t\t'\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\n\n\t\t'}',\n\n\t\t'vec3 blendOverlay( vec3 base, vec3 blend ) {',\n\n\t\t'\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',\n\n\t\t'}',\n\n\t\t'void main() {',\n\n\t\t'\tvec4 base = texture2DProj( tDiffuse, vUv );',\n\t\t'\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\n\n\t\t'}'\n\t].join( '\\n' )\n};\n"]}