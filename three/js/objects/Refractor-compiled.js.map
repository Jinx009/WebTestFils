{"version":3,"sources":["Refractor.js"],"names":[],"mappings":"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","file":"Refractor-compiled.js","sourcesContent":["console.warn( \"THREE.Refractor: As part of the transition to ES6 Modules, the files in 'examples/js' were deprecated in May 2020 (r117) and will be deleted in December 2020 (r124). You can find more information about developing using ES6 Modules in https://threejs.org/docs/#manual/en/introduction/Installation.\" );\n\nTHREE.Refractor = function ( geometry, options ) {\n\n\tTHREE.Mesh.call( this, geometry );\n\n\tthis.type = 'Refractor';\n\n\tvar scope = this;\n\n\toptions = options || {};\n\n\tvar color = ( options.color !== undefined ) ? new THREE.Color( options.color ) : new THREE.Color( 0x7F7F7F );\n\tvar textureWidth = options.textureWidth || 512;\n\tvar textureHeight = options.textureHeight || 512;\n\tvar clipBias = options.clipBias || 0;\n\tvar shader = options.shader || THREE.Refractor.RefractorShader;\n\n\t//\n\n\tvar virtualCamera = new THREE.PerspectiveCamera();\n\tvirtualCamera.matrixAutoUpdate = false;\n\tvirtualCamera.userData.refractor = true;\n\n\t//\n\n\tvar refractorPlane = new THREE.Plane();\n\tvar textureMatrix = new THREE.Matrix4();\n\n\t// render target\n\n\tvar parameters = {\n\t\tminFilter: THREE.LinearFilter,\n\t\tmagFilter: THREE.LinearFilter,\n\t\tformat: THREE.RGBFormat\n\t};\n\n\tvar renderTarget = new THREE.WebGLRenderTarget( textureWidth, textureHeight, parameters );\n\n\tif ( ! THREE.MathUtils.isPowerOfTwo( textureWidth ) || ! THREE.MathUtils.isPowerOfTwo( textureHeight ) ) {\n\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t}\n\n\t// material\n\n\tthis.material = new THREE.ShaderMaterial( {\n\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader,\n\t\ttransparent: true // ensures, refractors are drawn from farthest to closest\n\t} );\n\n\tthis.material.uniforms[ \"color\" ].value = color;\n\tthis.material.uniforms[ \"tDiffuse\" ].value = renderTarget.texture;\n\tthis.material.uniforms[ \"textureMatrix\" ].value = textureMatrix;\n\n\t// functions\n\n\tvar visible = ( function () {\n\n\t\tvar refractorWorldPosition = new THREE.Vector3();\n\t\tvar cameraWorldPosition = new THREE.Vector3();\n\t\tvar rotationMatrix = new THREE.Matrix4();\n\n\t\tvar view = new THREE.Vector3();\n\t\tvar normal = new THREE.Vector3();\n\n\t\treturn function visible( camera ) {\n\n\t\t\trefractorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\tview.subVectors( refractorWorldPosition, cameraWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\treturn view.dot( normal ) < 0;\n\n\t\t};\n\n\t} )();\n\n\tvar updateRefractorPlane = ( function () {\n\n\t\tvar normal = new THREE.Vector3();\n\t\tvar position = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar scale = new THREE.Vector3();\n\n\t\treturn function updateRefractorPlane() {\n\n\t\t\tscope.matrixWorld.decompose( position, quaternion, scale );\n\t\t\tnormal.set( 0, 0, 1 ).applyQuaternion( quaternion ).normalize();\n\n\t\t\t// flip the normal because we want to cull everything above the plane\n\n\t\t\tnormal.negate();\n\n\t\t\trefractorPlane.setFromNormalAndCoplanarPoint( normal, position );\n\n\t\t};\n\n\t} )();\n\n\tvar updateVirtualCamera = ( function () {\n\n\t\tvar clipPlane = new THREE.Plane();\n\t\tvar clipVector = new THREE.Vector4();\n\t\tvar q = new THREE.Vector4();\n\n\t\treturn function updateVirtualCamera( camera ) {\n\n\t\t\tvirtualCamera.matrixWorld.copy( camera.matrixWorld );\n\t\t\tvirtualCamera.matrixWorldInverse.getInverse( virtualCamera.matrixWorld );\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\t\t\tvirtualCamera.far = camera.far; // used in WebGLBackground\n\n\t\t\t// The following code creates an oblique view frustum for clipping.\n\t\t\t// see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\n\t\t\t// Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\n\n\t\t\tclipPlane.copy( refractorPlane );\n\t\t\tclipPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\tclipVector.set( clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant );\n\n\t\t\t// calculate the clip-space corner point opposite the clipping plane and\n\t\t\t// transform it into camera space by multiplying it by the inverse of the projection matrix\n\n\t\t\tvar projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\tq.x = ( Math.sign( clipVector.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\tq.y = ( Math.sign( clipVector.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\tq.z = - 1.0;\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t// calculate the scaled plane vector\n\n\t\t\tclipVector.multiplyScalar( 2.0 / clipVector.dot( q ) );\n\n\t\t\t// replacing the third row of the projection matrix\n\n\t\t\tprojectionMatrix.elements[ 2 ] = clipVector.x;\n\t\t\tprojectionMatrix.elements[ 6 ] = clipVector.y;\n\t\t\tprojectionMatrix.elements[ 10 ] = clipVector.z + 1.0 - clipBias;\n\t\t\tprojectionMatrix.elements[ 14 ] = clipVector.w;\n\n\t\t};\n\n\t} )();\n\n\t// This will update the texture matrix that is used for projective texture mapping in the shader.\n\t// see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\n\n\tfunction updateTextureMatrix( camera ) {\n\n\t\t// this matrix does range mapping to [ 0, 1 ]\n\n\t\ttextureMatrix.set(\n\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\n\t\t// we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\n\t\t// (matrix above) with the projection and view matrix of the virtual camera\n\t\t// and the model matrix of the refractor\n\n\t\ttextureMatrix.multiply( camera.projectionMatrix );\n\t\ttextureMatrix.multiply( camera.matrixWorldInverse );\n\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t}\n\n\t//\n\n\tfunction render( renderer, scene, camera ) {\n\n\t\tscope.visible = false;\n\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\t\tvar currentXrEnabled = renderer.xr.enabled;\n\t\tvar currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\trenderer.xr.enabled = false; // avoid camera modification\n\t\trenderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\n\n\t\trenderer.setRenderTarget( renderTarget );\n\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\trenderer.render( scene, virtualCamera );\n\n\t\trenderer.xr.enabled = currentXrEnabled;\n\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t// restore viewport\n\n\t\tvar viewport = camera.viewport;\n\n\t\tif ( viewport !== undefined ) {\n\n\t\t\trenderer.state.viewport( viewport );\n\n\t\t}\n\n\t\tscope.visible = true;\n\n\t}\n\n\t//\n\n\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t// Render\n\n\t\trenderTarget.texture.encoding = renderer.outputEncoding;\n\n\t\t// ensure refractors are rendered only once per frame\n\n\t\tif ( camera.userData.refractor === true ) return;\n\n\t\t// avoid rendering when the refractor is viewed from behind\n\n\t\tif ( ! visible( camera ) === true ) return;\n\n\t\t// update\n\n\t\tupdateRefractorPlane();\n\n\t\tupdateTextureMatrix( camera );\n\n\t\tupdateVirtualCamera( camera );\n\n\t\trender( renderer, scene, camera );\n\n\t};\n\n\tthis.getRenderTarget = function () {\n\n\t\treturn renderTarget;\n\n\t};\n\n};\n\nTHREE.Refractor.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.Refractor.prototype.constructor = THREE.Refractor;\n\nTHREE.Refractor.RefractorShader = {\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: [\n\n\t\t'uniform mat4 textureMatrix;',\n\n\t\t'varying vec4 vUv;',\n\n\t\t'void main() {',\n\n\t\t'\tvUv = textureMatrix * vec4( position, 1.0 );',\n\n\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n\t\t'}'\n\n\t].join( '\\n' ),\n\n\tfragmentShader: [\n\n\t\t'uniform vec3 color;',\n\t\t'uniform sampler2D tDiffuse;',\n\n\t\t'varying vec4 vUv;',\n\n\t\t'float blendOverlay( float base, float blend ) {',\n\n\t\t'\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );',\n\n\t\t'}',\n\n\t\t'vec3 blendOverlay( vec3 base, vec3 blend ) {',\n\n\t\t'\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );',\n\n\t\t'}',\n\n\t\t'void main() {',\n\n\t\t'\tvec4 base = texture2DProj( tDiffuse, vUv );',\n\n\t\t'\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );',\n\n\t\t'}'\n\n\t].join( '\\n' )\n};\n"]}