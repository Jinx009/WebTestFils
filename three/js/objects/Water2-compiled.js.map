{"version":3,"sources":["Water2.js"],"names":[],"mappings":"AAAA,QAAQ,IAAR,CAAc,uSAAd;AACA;;;;;;;AAOA,MAAM,KAAN,GAAc,UAAW,QAAX,EAAqB,OAArB,EAA+B;;AAE5C,OAAM,IAAN,CAAW,IAAX,CAAiB,IAAjB,EAAuB,QAAvB;;AAEA,MAAK,IAAL,GAAY,OAAZ;;AAEA,KAAI,QAAQ,IAAZ;;AAEA,WAAU,WAAW,EAArB;;AAEA,KAAI,QAAU,QAAQ,KAAR,KAAkB,SAApB,GAAkC,IAAI,MAAM,KAAV,CAAiB,QAAQ,KAAzB,CAAlC,GAAqE,IAAI,MAAM,KAAV,CAAiB,QAAjB,CAAjF;AACA,KAAI,eAAe,QAAQ,YAAR,IAAwB,GAA3C;AACA,KAAI,gBAAgB,QAAQ,aAAR,IAAyB,GAA7C;AACA,KAAI,WAAW,QAAQ,QAAR,IAAoB,CAAnC;AACA,KAAI,gBAAgB,QAAQ,aAAR,IAAyB,IAAI,MAAM,OAAV,CAAmB,CAAnB,EAAsB,CAAtB,CAA7C;AACA,KAAI,YAAY,QAAQ,SAAR,IAAqB,IAArC;AACA,KAAI,eAAe,QAAQ,YAAR,IAAwB,IAA3C;AACA,KAAI,QAAQ,QAAQ,KAAR,IAAiB,CAA7B;AACA,KAAI,SAAS,QAAQ,MAAR,IAAkB,MAAM,KAAN,CAAY,WAA3C;AACA,KAAI,WAAW,QAAQ,QAAR,KAAqB,SAArB,GAAiC,QAAQ,QAAzC,GAAoD,MAAM,cAAzE;;AAEA,KAAI,gBAAgB,IAAI,MAAM,aAAV,EAApB;;AAEA,KAAI,UAAU,QAAQ,OAAR,IAAmB,SAAjC;AACA,KAAI,aAAa,QAAQ,UAAR,IAAsB,cAAc,IAAd,CAAoB,qCAApB,CAAvC;AACA,KAAI,aAAa,QAAQ,UAAR,IAAsB,cAAc,IAAd,CAAoB,qCAApB,CAAvC;;AAEA,KAAI,QAAQ,IAAZ,CA3B4C,CA2B1B;AAClB,KAAI,YAAY,QAAQ,GAAxB;AACA,KAAI,gBAAgB,IAAI,MAAM,OAAV,EAApB;AACA,KAAI,QAAQ,IAAI,MAAM,KAAV,EAAZ;;AAEA;;AAEA,KAAK,MAAM,SAAN,KAAoB,SAAzB,EAAqC;;AAEpC,UAAQ,KAAR,CAAe,4DAAf;AACA;AAEA;;AAED,KAAK,MAAM,SAAN,KAAoB,SAAzB,EAAqC;;AAEpC,UAAQ,KAAR,CAAe,4DAAf;AACA;AAEA;;AAED,KAAI,YAAY,IAAI,MAAM,SAAV,CAAqB,QAArB,EAA+B;AAC9C,gBAAc,YADgC;AAE9C,iBAAe,aAF+B;AAG9C,YAAU,QAHoC;AAI9C,YAAU;AAJoC,EAA/B,CAAhB;;AAOA,KAAI,YAAY,IAAI,MAAM,SAAV,CAAqB,QAArB,EAA+B;AAC9C,gBAAc,YADgC;AAE9C,iBAAe,aAF+B;AAG9C,YAAU,QAHoC;AAI9C,YAAU;AAJoC,EAA/B,CAAhB;;AAOA,WAAU,gBAAV,GAA6B,KAA7B;AACA,WAAU,gBAAV,GAA6B,KAA7B;;AAEA;;AAEA,MAAK,QAAL,GAAgB,IAAI,MAAM,cAAV,CAA0B;AACzC,YAAU,MAAM,aAAN,CAAoB,KAApB,CAA2B,CACpC,MAAM,WAAN,CAAmB,KAAnB,CADoC,EAEpC,OAAO,QAF6B,CAA3B,CAD+B;AAKzC,gBAAc,OAAO,YALoB;AAMzC,kBAAgB,OAAO,cANkB;AAOzC,eAAa,IAP4B;AAQzC,OAAK;AARoC,EAA1B,CAAhB;;AAWA,KAAK,YAAY,SAAjB,EAA6B;;AAE5B,OAAK,QAAL,CAAc,OAAd,CAAsB,WAAtB,GAAoC,EAApC;AACA,OAAK,QAAL,CAAc,QAAd,CAAwB,UAAxB,IAAuC;AACtC,SAAM,GADgC;AAEtC,UAAO;AAF+B,GAAvC;AAKA,EARD,MAQO;;AAEN,OAAK,QAAL,CAAc,QAAd,CAAwB,eAAxB,IAA4C;AAC3C,SAAM,IADqC;AAE3C,UAAO;AAFoC,GAA5C;AAKA;;AAED;;AAEA,YAAW,KAAX,GAAmB,WAAW,KAAX,GAAmB,MAAM,cAA5C;AACA,YAAW,KAAX,GAAmB,WAAW,KAAX,GAAmB,MAAM,cAA5C;;AAEA,MAAK,QAAL,CAAc,QAAd,CAAwB,gBAAxB,EAA2C,KAA3C,GAAmD,UAAU,eAAV,GAA4B,OAA/E;AACA,MAAK,QAAL,CAAc,QAAd,CAAwB,gBAAxB,EAA2C,KAA3C,GAAmD,UAAU,eAAV,GAA4B,OAA/E;AACA,MAAK,QAAL,CAAc,QAAd,CAAwB,aAAxB,EAAwC,KAAxC,GAAgD,UAAhD;AACA,MAAK,QAAL,CAAc,QAAd,CAAwB,aAAxB,EAAwC,KAAxC,GAAgD,UAAhD;;AAEA;;AAEA,MAAK,QAAL,CAAc,QAAd,CAAwB,OAAxB,EAAkC,KAAlC,GAA0C,KAA1C;AACA,MAAK,QAAL,CAAc,QAAd,CAAwB,cAAxB,EAAyC,KAAzC,GAAiD,YAAjD;AACA,MAAK,QAAL,CAAc,QAAd,CAAwB,eAAxB,EAA0C,KAA1C,GAAkD,aAAlD;;AAEA;;AAEA,MAAK,QAAL,CAAc,QAAd,CAAwB,QAAxB,EAAmC,KAAnC,CAAyC,CAAzC,GAA6C,CAA7C,CAjH4C,CAiHI;AAChD,MAAK,QAAL,CAAc,QAAd,CAAwB,QAAxB,EAAmC,KAAnC,CAAyC,CAAzC,GAA6C,SAA7C,CAlH4C,CAkHY;AACxD,MAAK,QAAL,CAAc,QAAd,CAAwB,QAAxB,EAAmC,KAAnC,CAAyC,CAAzC,GAA6C,SAA7C,CAnH4C,CAmHY;AACxD,MAAK,QAAL,CAAc,QAAd,CAAwB,QAAxB,EAAmC,KAAnC,CAAyC,CAAzC,GAA6C,KAA7C,CApH4C,CAoHQ;;AAEpD;;AAEA,UAAS,mBAAT,CAA8B,MAA9B,EAAuC;;AAEtC,gBAAc,GAAd,CACC,GADD,EACM,GADN,EACW,GADX,EACgB,GADhB,EAEC,GAFD,EAEM,GAFN,EAEW,GAFX,EAEgB,GAFhB,EAGC,GAHD,EAGM,GAHN,EAGW,GAHX,EAGgB,GAHhB,EAIC,GAJD,EAIM,GAJN,EAIW,GAJX,EAIgB,GAJhB;;AAOA,gBAAc,QAAd,CAAwB,OAAO,gBAA/B;AACA,gBAAc,QAAd,CAAwB,OAAO,kBAA/B;AACA,gBAAc,QAAd,CAAwB,MAAM,WAA9B;AAEA;;AAED,UAAS,UAAT,GAAsB;;AAErB,MAAI,QAAQ,MAAM,QAAN,EAAZ;AACA,MAAI,SAAS,MAAM,QAAN,CAAe,QAAf,CAAyB,QAAzB,CAAb;;AAEA,SAAO,KAAP,CAAa,CAAb,IAAkB,YAAY,KAA9B,CALqB,CAKgB;AACrC,SAAO,KAAP,CAAa,CAAb,GAAiB,OAAO,KAAP,CAAa,CAAb,GAAiB,SAAlC,CANqB,CAMwB;;AAE7C;AACA;AACA;;AAEA,MAAK,OAAO,KAAP,CAAa,CAAb,IAAkB,KAAvB,EAA+B;;AAE9B,UAAO,KAAP,CAAa,CAAb,GAAiB,CAAjB;AACA,UAAO,KAAP,CAAa,CAAb,GAAiB,SAAjB;AAEA,GALD,MAKO,IAAK,OAAO,KAAP,CAAa,CAAb,IAAkB,KAAvB,EAA+B;;AAErC,UAAO,KAAP,CAAa,CAAb,GAAiB,OAAO,KAAP,CAAa,CAAb,GAAiB,KAAlC;AAEA;AAED;;AAED;;AAEA,MAAK,cAAL,GAAsB,UAAW,QAAX,EAAqB,KAArB,EAA4B,MAA5B,EAAqC;;AAE1D,sBAAqB,MAArB;AACA;;AAEA,QAAM,OAAN,GAAgB,KAAhB;;AAEA,YAAU,WAAV,CAAsB,IAAtB,CAA4B,MAAM,WAAlC;AACA,YAAU,WAAV,CAAsB,IAAtB,CAA4B,MAAM,WAAlC;;AAEA,YAAU,cAAV,CAA0B,QAA1B,EAAoC,KAApC,EAA2C,MAA3C;AACA,YAAU,cAAV,CAA0B,QAA1B,EAAoC,KAApC,EAA2C,MAA3C;;AAEA,QAAM,OAAN,GAAgB,IAAhB;AAEA,EAfD;AAiBA,CAnLD;;AAqLA,MAAM,KAAN,CAAY,SAAZ,GAAwB,OAAO,MAAP,CAAe,MAAM,IAAN,CAAW,SAA1B,CAAxB;AACA,MAAM,KAAN,CAAY,SAAZ,CAAsB,WAAtB,GAAoC,MAAM,KAA1C;;AAEA,MAAM,KAAN,CAAY,WAAZ,GAA0B;;AAEzB,WAAU;;AAET,WAAS;AACR,SAAM,GADE;AAER,UAAO;AAFC,GAFA;;AAOT,kBAAgB;AACf,SAAM,GADS;AAEf,UAAO;AAFQ,GAPP;;AAYT,oBAAkB;AACjB,SAAM,GADW;AAEjB,UAAO;AAFU,GAZT;;AAiBT,oBAAkB;AACjB,SAAM,GADW;AAEjB,UAAO;AAFU,GAjBT;;AAsBT,iBAAe;AACd,SAAM,GADQ;AAEd,UAAO;AAFO,GAtBN;;AA2BT,iBAAe;AACd,SAAM,GADQ;AAEd,UAAO;AAFO,GA3BN;;AAgCT,mBAAiB;AAChB,SAAM,IADU;AAEhB,UAAO;AAFS,GAhCR;;AAqCT,YAAU;AACT,SAAM,IADG;AAET,UAAO,IAAI,MAAM,OAAV;AAFE;;AArCD,EAFe;;AA8CzB,eAAc,CAEb,mBAFa,EAGb,4BAHa,EAIb,oCAJa,EAMb,6BANa,EAQb,sBARa,EASb,mBATa,EAUb,sBAVa,EAYb,eAZa,EAcb,YAda,EAeb,kDAfa,EAiBb,4DAjBa,EAkBb,+CAlBa,EAoBb,iDApBa,EAoBsC;AACnD,gDArBa,EAuBb,gCAvBa,EAwBb,wBAxBa,EA0Bb,GA1Ba,EA4BZ,IA5BY,CA4BN,IA5BM,CA9CW;;AA4EzB,iBAAgB,CAEf,mBAFe,EAGf,8BAHe,EAIf,sCAJe,EAMf,mCANe,EAOf,mCAPe,EAQf,gCARe,EASf,gCATe,EAWf,oBAXe,EAYf,8BAZe,EAaf,OAbe,EAcf,8BAde,EAef,QAfe,EAiBf,qBAjBe,EAkBf,6BAlBe,EAmBf,sBAnBe,EAqBf,sBArBe,EAsBf,mBAtBe,EAuBf,sBAvBe,EAyBf,eAzBe,EA2Bf,kCA3Be,EA6Bf,mCA7Be,EA8Bf,mCA9Be,EA+Bf,8BA/Be,EAgCf,0BAhCe,EAkCf,oCAlCe;;AAoCf;AACA,cArCe,EAsCf,qBAtCe,EAuCf,qDAvCe,EAwCf,QAxCe,EAyCf,yBAzCe,EA0Cf,SA1Ce,EA2Cf,mBA3Ce;;AA6Cf;AACA,0FA9Ce,EA+Cf,yFA/Ce;;AAiDf;AACA,mEAlDe,EAmDf,kEAnDe;;AAqDf;AACA,4GAtDe;;AAwDf;AACA,mDAzDe,EA0Df,2FA1De;;AA4Df;AACA,uCA7De,EA8Df,mDA9De,EAgEf,6EAhEe,EAiEf,uDAjEe;;AAmEf;AACA,uFApEe,EAsEf,kCAtEe,EAuEf,gCAvEe,EAwEf,0BAxEe,EA0Ef,GA1Ee,EA4Ed,IA5Ec,CA4ER,IA5EQ;AA5ES,CAA1B","file":"Water2-compiled.js","sourcesContent":["console.warn( \"THREE.Water2: As part of the transition to ES6 Modules, the files in 'examples/js' were deprecated in May 2020 (r117) and will be deleted in December 2020 (r124). You can find more information about developing using ES6 Modules in https://threejs.org/docs/#manual/en/introduction/Installation.\" );\n/**\n * References:\n *\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\n * \thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\n *\n */\n\nTHREE.Water = function ( geometry, options ) {\n\n\tTHREE.Mesh.call( this, geometry );\n\n\tthis.type = 'Water';\n\n\tvar scope = this;\n\n\toptions = options || {};\n\n\tvar color = ( options.color !== undefined ) ? new THREE.Color( options.color ) : new THREE.Color( 0xFFFFFF );\n\tvar textureWidth = options.textureWidth || 512;\n\tvar textureHeight = options.textureHeight || 512;\n\tvar clipBias = options.clipBias || 0;\n\tvar flowDirection = options.flowDirection || new THREE.Vector2( 1, 0 );\n\tvar flowSpeed = options.flowSpeed || 0.03;\n\tvar reflectivity = options.reflectivity || 0.02;\n\tvar scale = options.scale || 1;\n\tvar shader = options.shader || THREE.Water.WaterShader;\n\tvar encoding = options.encoding !== undefined ? options.encoding : THREE.LinearEncoding;\n\n\tvar textureLoader = new THREE.TextureLoader();\n\n\tvar flowMap = options.flowMap || undefined;\n\tvar normalMap0 = options.normalMap0 || textureLoader.load( 'textures/water/Water_1_M_Normal.jpg' );\n\tvar normalMap1 = options.normalMap1 || textureLoader.load( 'textures/water/Water_2_M_Normal.jpg' );\n\n\tvar cycle = 0.15; // a cycle of a flow map phase\n\tvar halfCycle = cycle * 0.5;\n\tvar textureMatrix = new THREE.Matrix4();\n\tvar clock = new THREE.Clock();\n\n\t// internal components\n\n\tif ( THREE.Reflector === undefined ) {\n\n\t\tconsole.error( 'THREE.Water: Required component THREE.Reflector not found.' );\n\t\treturn;\n\n\t}\n\n\tif ( THREE.Refractor === undefined ) {\n\n\t\tconsole.error( 'THREE.Water: Required component THREE.Refractor not found.' );\n\t\treturn;\n\n\t}\n\n\tvar reflector = new THREE.Reflector( geometry, {\n\t\ttextureWidth: textureWidth,\n\t\ttextureHeight: textureHeight,\n\t\tclipBias: clipBias,\n\t\tencoding: encoding\n\t} );\n\n\tvar refractor = new THREE.Refractor( geometry, {\n\t\ttextureWidth: textureWidth,\n\t\ttextureHeight: textureHeight,\n\t\tclipBias: clipBias,\n\t\tencoding: encoding\n\t} );\n\n\treflector.matrixAutoUpdate = false;\n\trefractor.matrixAutoUpdate = false;\n\n\t// material\n\n\tthis.material = new THREE.ShaderMaterial( {\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\t\t\tTHREE.UniformsLib[ 'fog' ],\n\t\t\tshader.uniforms\n\t\t] ),\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader,\n\t\ttransparent: true,\n\t\tfog: true\n\t} );\n\n\tif ( flowMap !== undefined ) {\n\n\t\tthis.material.defines.USE_FLOWMAP = '';\n\t\tthis.material.uniforms[ \"tFlowMap\" ] = {\n\t\t\ttype: 't',\n\t\t\tvalue: flowMap\n\t\t};\n\n\t} else {\n\n\t\tthis.material.uniforms[ \"flowDirection\" ] = {\n\t\t\ttype: 'v2',\n\t\t\tvalue: flowDirection\n\t\t};\n\n\t}\n\n\t// maps\n\n\tnormalMap0.wrapS = normalMap0.wrapT = THREE.RepeatWrapping;\n\tnormalMap1.wrapS = normalMap1.wrapT = THREE.RepeatWrapping;\n\n\tthis.material.uniforms[ \"tReflectionMap\" ].value = reflector.getRenderTarget().texture;\n\tthis.material.uniforms[ \"tRefractionMap\" ].value = refractor.getRenderTarget().texture;\n\tthis.material.uniforms[ \"tNormalMap0\" ].value = normalMap0;\n\tthis.material.uniforms[ \"tNormalMap1\" ].value = normalMap1;\n\n\t// water\n\n\tthis.material.uniforms[ \"color\" ].value = color;\n\tthis.material.uniforms[ \"reflectivity\" ].value = reflectivity;\n\tthis.material.uniforms[ \"textureMatrix\" ].value = textureMatrix;\n\n\t// inital values\n\n\tthis.material.uniforms[ \"config\" ].value.x = 0; // flowMapOffset0\n\tthis.material.uniforms[ \"config\" ].value.y = halfCycle; // flowMapOffset1\n\tthis.material.uniforms[ \"config\" ].value.z = halfCycle; // halfCycle\n\tthis.material.uniforms[ \"config\" ].value.w = scale; // scale\n\n\t// functions\n\n\tfunction updateTextureMatrix( camera ) {\n\n\t\ttextureMatrix.set(\n\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t);\n\n\t\ttextureMatrix.multiply( camera.projectionMatrix );\n\t\ttextureMatrix.multiply( camera.matrixWorldInverse );\n\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t}\n\n\tfunction updateFlow() {\n\n\t\tvar delta = clock.getDelta();\n\t\tvar config = scope.material.uniforms[ \"config\" ];\n\n\t\tconfig.value.x += flowSpeed * delta; // flowMapOffset0\n\t\tconfig.value.y = config.value.x + halfCycle; // flowMapOffset1\n\n\t\t// Important: The distance between offsets should be always the value of \"halfCycle\".\n\t\t// Moreover, both offsets should be in the range of [ 0, cycle ].\n\t\t// This approach ensures a smooth water flow and avoids \"reset\" effects.\n\n\t\tif ( config.value.x >= cycle ) {\n\n\t\t\tconfig.value.x = 0;\n\t\t\tconfig.value.y = halfCycle;\n\n\t\t} else if ( config.value.y >= cycle ) {\n\n\t\t\tconfig.value.y = config.value.y - cycle;\n\n\t\t}\n\n\t}\n\n\t//\n\n\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\tupdateTextureMatrix( camera );\n\t\tupdateFlow();\n\n\t\tscope.visible = false;\n\n\t\treflector.matrixWorld.copy( scope.matrixWorld );\n\t\trefractor.matrixWorld.copy( scope.matrixWorld );\n\n\t\treflector.onBeforeRender( renderer, scene, camera );\n\t\trefractor.onBeforeRender( renderer, scene, camera );\n\n\t\tscope.visible = true;\n\n\t};\n\n};\n\nTHREE.Water.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.Water.prototype.constructor = THREE.Water;\n\nTHREE.Water.WaterShader = {\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\ttype: 'c',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'reflectivity': {\n\t\t\ttype: 'f',\n\t\t\tvalue: 0\n\t\t},\n\n\t\t'tReflectionMap': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tRefractionMap': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tNormalMap0': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tNormalMap1': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\ttype: 'm4',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'config': {\n\t\t\ttype: 'v4',\n\t\t\tvalue: new THREE.Vector4()\n\t\t}\n\n\t},\n\n\tvertexShader: [\n\n\t\t'#include <common>',\n\t\t'#include <fog_pars_vertex>',\n\t\t'#include <logdepthbuf_pars_vertex>',\n\n\t\t'uniform mat4 textureMatrix;',\n\n\t\t'varying vec4 vCoord;',\n\t\t'varying vec2 vUv;',\n\t\t'varying vec3 vToEye;',\n\n\t\t'void main() {',\n\n\t\t'\tvUv = uv;',\n\t\t'\tvCoord = textureMatrix * vec4( position, 1.0 );',\n\n\t\t'\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );',\n\t\t'\tvToEye = cameraPosition - worldPosition.xyz;',\n\n\t\t'\tvec4 mvPosition =  viewMatrix * worldPosition;', // used in fog_vertex\n\t\t'\tgl_Position = projectionMatrix * mvPosition;',\n\n\t\t'\t#include <logdepthbuf_vertex>',\n\t\t'\t#include <fog_vertex>',\n\n\t\t'}'\n\n\t].join( '\\n' ),\n\n\tfragmentShader: [\n\n\t\t'#include <common>',\n\t\t'#include <fog_pars_fragment>',\n\t\t'#include <logdepthbuf_pars_fragment>',\n\n\t\t'uniform sampler2D tReflectionMap;',\n\t\t'uniform sampler2D tRefractionMap;',\n\t\t'uniform sampler2D tNormalMap0;',\n\t\t'uniform sampler2D tNormalMap1;',\n\n\t\t'#ifdef USE_FLOWMAP',\n\t\t'\tuniform sampler2D tFlowMap;',\n\t\t'#else',\n\t\t'\tuniform vec2 flowDirection;',\n\t\t'#endif',\n\n\t\t'uniform vec3 color;',\n\t\t'uniform float reflectivity;',\n\t\t'uniform vec4 config;',\n\n\t\t'varying vec4 vCoord;',\n\t\t'varying vec2 vUv;',\n\t\t'varying vec3 vToEye;',\n\n\t\t'void main() {',\n\n\t\t'\t#include <logdepthbuf_fragment>',\n\n\t\t'\tfloat flowMapOffset0 = config.x;',\n\t\t'\tfloat flowMapOffset1 = config.y;',\n\t\t'\tfloat halfCycle = config.z;',\n\t\t'\tfloat scale = config.w;',\n\n\t\t'\tvec3 toEye = normalize( vToEye );',\n\n\t\t// determine flow direction\n\t\t'\tvec2 flow;',\n\t\t'\t#ifdef USE_FLOWMAP',\n\t\t'\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;',\n\t\t'\t#else',\n\t\t'\t\tflow = flowDirection;',\n\t\t'\t#endif',\n\t\t'\tflow.x *= - 1.0;',\n\n\t\t// sample normal maps (distort uvs with flowdata)\n\t\t'\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );',\n\t\t'\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );',\n\n\t\t// linear interpolate to get the final normal color\n\t\t'\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;',\n\t\t'\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );',\n\n\t\t// calculate normal vector\n\t\t'\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );',\n\n\t\t// calculate the fresnel term to blend reflection and refraction maps\n\t\t'\tfloat theta = max( dot( toEye, normal ), 0.0 );',\n\t\t'\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );',\n\n\t\t// calculate final uv coords\n\t\t'\tvec3 coord = vCoord.xyz / vCoord.w;',\n\t\t'\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;',\n\n\t\t'\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );',\n\t\t'\tvec4 refractColor = texture2D( tRefractionMap, uv );',\n\n\t\t// multiply water color with the mix of both textures\n\t\t'\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );',\n\n\t\t'\t#include <tonemapping_fragment>',\n\t\t'\t#include <encodings_fragment>',\n\t\t'\t#include <fog_fragment>',\n\n\t\t'}'\n\n\t].join( '\\n' )\n};\n"]}