{"version":3,"sources":["DigitalGlitch.js"],"names":[],"mappings":"AAAA,QAAQ,IAAR,CAAc,8SAAd;AACA;;;;;;;;;;AAUA,MAAM,aAAN,GAAsB;;AAErB,WAAU;;AAET,cAAY,EAAE,OAAO,IAAT,EAFH,EAEoB;AAC7B,WAAS,EAAE,OAAO,IAAT,EAHA,EAGiB;AAC1B,SAAO,EAAE,OAAO,CAAT,EAJE,EAIY;AACrB,YAAU,EAAE,OAAO,IAAT,EALD;AAMT,WAAS,EAAE,OAAO,IAAT,EANA;AAOT,UAAQ,EAAE,OAAO,IAAT,EAPC;AAQT,YAAU,EAAE,OAAO,IAAT,EARD,EAQkB;AAC3B,YAAU,EAAE,OAAO,IAAT,EATD,EASkB;AAC3B,kBAAgB,EAAE,OAAO,GAAT,EAVP;AAWT,kBAAgB,EAAE,OAAO,GAAT,EAXP;AAYT,WAAS,EAAE,OAAO,IAAT;AAZA,EAFW;;AAiBrB,eAAc,CAEb,mBAFa,EAGb,eAHa,EAIb,YAJa,EAKb,4EALa,EAMb,GANa,EAOZ,IAPY,CAON,IAPM,CAjBO;;AA0BrB,iBAAgB,CACf,kBADe,EACK;;AAEpB,8BAHe,EAIf,0BAJe,EAMf,uBANe,EAOf,sBAPe,EAQf,qBARe,EASf,uBATe,EAUf,uBAVe,EAWf,6BAXe,EAYf,6BAZe,EAaf,sBAbe,EAef,mBAfe,EAkBf,sBAlBe,EAmBf,oEAnBe,EAoBf,GApBe,EAsBf,eAtBe,EAuBf,cAvBe,EAwBf,iBAxBe,EAyBf,2CAzBe,EA0Bf,2CA1Be;AA2Bf;AACA,kDA5Be,EA6Bf,+DA7Be,EA8Bf,mBA9Be,EA+Bf,sCA/Be,EAgCf,MAhCe,EAiCf,WAjCe,EAkCf,yBAlCe,EAmCf,MAnCe,EAoCf,KApCe,EAqCf,+DArCe,EAsCf,mBAtCe,EAuCf,uBAvCe,EAwCf,MAxCe,EAyCf,WAzCe,EA0Cf,sCA1Ce,EA2Cf,MA3Ce,EA4Cf,KA5Ce,EA6Cf,mCA7Ce,EA8Cf,mCA9Ce;AA+Cf;AACA,0DAhDe,EAiDf,8CAjDe,EAkDf,sCAlDe,EAmDf,8CAnDe,EAoDf,kDApDe;AAqDf;AACA,2EAtDe,EAuDf,sCAvDe,EAwDf,IAxDe,EAyDf,SAzDe,EA0Df,2CA1De,EA2Df,IA3De,EA4Df,GA5De,EA8Dd,IA9Dc,CA8DR,IA9DQ;;AA1BK,CAAtB","file":"DigitalGlitch-compiled.js","sourcesContent":["console.warn( \"THREE.DigitalGlitch: As part of the transition to ES6 Modules, the files in 'examples/js' were deprecated in May 2020 (r117) and will be deleted in December 2020 (r124). You can find more information about developing using ES6 Modules in https://threejs.org/docs/#manual/en/introduction/Installation.\" );\n/**\n * RGB Shift Shader\n * Shifts red and blue channels from center in opposite directions\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n * by Tom Butterworth / http://kriss.cx/tom/\n *\n * amount: shift distance (1 is width of input)\n * angle: shift angle in radians\n */\n\nTHREE.DigitalGlitch = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null }, //diffuse texture\n\t\t\"tDisp\": { value: null }, //displacement texture for digital glitch squares\n\t\t\"byp\": { value: 0 }, //apply the glitch ?\n\t\t\"amount\": { value: 0.08 },\n\t\t\"angle\": { value: 0.02 },\n\t\t\"seed\": { value: 0.02 },\n\t\t\"seed_x\": { value: 0.02 }, //-1,1\n\t\t\"seed_y\": { value: 0.02 }, //-1,1\n\t\t\"distortion_x\": { value: 0.5 },\n\t\t\"distortion_y\": { value: 0.6 },\n\t\t\"col_s\": { value: 0.05 }\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\t\t\"void main() {\",\n\t\t\"\tvUv = uv;\",\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\"}\"\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\t\t\"uniform int byp;\", //should we apply the glitch ?\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform sampler2D tDisp;\",\n\n\t\t\"uniform float amount;\",\n\t\t\"uniform float angle;\",\n\t\t\"uniform float seed;\",\n\t\t\"uniform float seed_x;\",\n\t\t\"uniform float seed_y;\",\n\t\t\"uniform float distortion_x;\",\n\t\t\"uniform float distortion_y;\",\n\t\t\"uniform float col_s;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\n\t\t\"float rand(vec2 co){\",\n\t\t\"\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\",\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\t\t\"\tif(byp<1) {\",\n\t\t\"\t\tvec2 p = vUv;\",\n\t\t\"\t\tfloat xs = floor(gl_FragCoord.x / 0.5);\",\n\t\t\"\t\tfloat ys = floor(gl_FragCoord.y / 0.5);\",\n\t\t//based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\n\t\t\"\t\tvec4 normal = texture2D (tDisp, p*seed*seed);\",\n\t\t\"\t\tif(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {\",\n\t\t\"\t\t\tif(seed_x>0.){\",\n\t\t\"\t\t\t\tp.y = 1. - (p.y + distortion_y);\",\n\t\t\"\t\t\t}\",\n\t\t\"\t\t\telse {\",\n\t\t\"\t\t\t\tp.y = distortion_y;\",\n\t\t\"\t\t\t}\",\n\t\t\"\t\t}\",\n\t\t\"\t\tif(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {\",\n\t\t\"\t\t\tif(seed_y>0.){\",\n\t\t\"\t\t\t\tp.x=distortion_x;\",\n\t\t\"\t\t\t}\",\n\t\t\"\t\t\telse {\",\n\t\t\"\t\t\t\tp.x = 1. - (p.x + distortion_x);\",\n\t\t\"\t\t\t}\",\n\t\t\"\t\t}\",\n\t\t\"\t\tp.x+=normal.x*seed_x*(seed/5.);\",\n\t\t\"\t\tp.y+=normal.y*seed_y*(seed/5.);\",\n\t\t//base from RGB shift shader\n\t\t\"\t\tvec2 offset = amount * vec2( cos(angle), sin(angle));\",\n\t\t\"\t\tvec4 cr = texture2D(tDiffuse, p + offset);\",\n\t\t\"\t\tvec4 cga = texture2D(tDiffuse, p);\",\n\t\t\"\t\tvec4 cb = texture2D(tDiffuse, p - offset);\",\n\t\t\"\t\tgl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\",\n\t\t//add noise\n\t\t\"\t\tvec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);\",\n\t\t\"\t\tgl_FragColor = gl_FragColor+ snow;\",\n\t\t\"\t}\",\n\t\t\"\telse {\",\n\t\t\"\t\tgl_FragColor=texture2D (tDiffuse, vUv);\",\n\t\t\"\t}\",\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n"]}