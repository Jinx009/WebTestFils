{"version":3,"sources":["ConvolutionShader.js"],"names":[],"mappings":"AAAA,QAAQ,IAAR,CAAc,kTAAd;AACA;;;;;;AAMA,MAAM,iBAAN,GAA0B;;AAEzB,UAAS;;AAER,uBAAqB,MAFb;AAGR,qBAAmB;;AAHX,EAFgB;;AASzB,WAAU;;AAET,cAAY,EAAE,OAAO,IAAT,EAFH;AAGT,qBAAmB,EAAE,OAAO,IAAI,MAAM,OAAV,CAAmB,WAAnB,EAAgC,GAAhC,CAAT,EAHV;AAIT,aAAW,EAAE,OAAO,EAAT;;AAJF,EATe;;AAiBzB,eAAc,CAEb,+BAFa,EAIb,mBAJa,EAMb,eANa,EAQb,sEARa,EASb,4EATa,EAWb,GAXa,EAaZ,IAbY,CAaN,IAbM,CAjBW;;AAgCzB,iBAAgB,CAEf,2CAFe,EAIf,6BAJe,EAKf,+BALe,EAOf,mBAPe,EASf,eATe,EAWf,yBAXe,EAYf,yCAZe,EAcf,gDAde,EAgBf,4DAhBe,EAiBf,kCAjBe,EAmBf,IAnBe,EAqBf,sBArBe,EAuBf,GAvBe,EA0Bd,IA1Bc,CA0BR,IA1BQ,CAhCS;;AA4DzB,cAAa,UAAW,KAAX,EAAmB;;AAE/B;;AAEA,WAAS,KAAT,CAAgB,CAAhB,EAAmB,KAAnB,EAA2B;;AAE1B,UAAO,KAAK,GAAL,CAAU,EAAI,IAAI,CAAR,KAAgB,MAAM,KAAN,GAAc,KAA9B,CAAV,CAAP;AAEA;;AAED,MAAI,CAAJ;AAAA,MAAO,MAAP;AAAA,MAAe,GAAf;AAAA,MAAoB,SAApB;AAAA,MAA+B,iBAAiB,EAAhD;AAAA,MAAoD,aAAa,IAAI,KAAK,IAAL,CAAW,QAAQ,GAAnB,CAAJ,GAA+B,CAAhG;;AAEA,MAAK,aAAa,cAAlB,EAAmC,aAAa,cAAb;AACnC,cAAY,CAAE,aAAa,CAAf,IAAqB,GAAjC;;AAEA,WAAS,IAAI,KAAJ,CAAW,UAAX,CAAT;AACA,QAAM,GAAN;AACA,OAAM,IAAI,CAAV,EAAa,IAAI,UAAjB,EAA6B,EAAG,CAAhC,EAAoC;;AAEnC,UAAQ,CAAR,IAAc,MAAO,IAAI,SAAX,EAAsB,KAAtB,CAAd;AACA,UAAO,OAAQ,CAAR,CAAP;AAEA;;AAED;;AAEA,OAAM,IAAI,CAAV,EAAa,IAAI,UAAjB,EAA6B,EAAG,CAAhC,EAAoC,OAAQ,CAAR,KAAe,GAAf;;AAEpC,SAAO,MAAP;AAEA;;AA1FwB,CAA1B","file":"ConvolutionShader-compiled.js","sourcesContent":["console.warn( \"THREE.ConvolutionShader: As part of the transition to ES6 Modules, the files in 'examples/js' were deprecated in May 2020 (r117) and will be deleted in December 2020 (r124). You can find more information about developing using ES6 Modules in https://threejs.org/docs/#manual/en/introduction/Installation.\" );\n/**\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\n\nTHREE.ConvolutionShader = {\n\n\tdefines: {\n\n\t\t\"KERNEL_SIZE_FLOAT\": \"25.0\",\n\t\t\"KERNEL_SIZE_INT\": \"25\"\n\n\t},\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"uImageIncrement\": { value: new THREE.Vector2( 0.001953125, 0.0 ) },\n\t\t\"cKernel\": { value: [] }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"uniform vec2 uImageIncrement;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\",\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"uniform float cKernel[ KERNEL_SIZE_INT ];\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform vec2 uImageIncrement;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvec2 imageCoord = vUv;\",\n\t\t\"\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\",\n\n\t\t\"\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\",\n\n\t\t\"\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\",\n\t\t\"\t\timageCoord += uImageIncrement;\",\n\n\t\t\"\t}\",\n\n\t\t\"\tgl_FragColor = sum;\",\n\n\t\t\"}\"\n\n\n\t].join( \"\\n\" ),\n\n\tbuildKernel: function ( sigma ) {\n\n\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n\n\t\tfunction gauss( x, sigma ) {\n\n\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\n\n\t\t}\n\n\t\tvar i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\n\n\t\tif ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;\n\t\thalfWidth = ( kernelSize - 1 ) * 0.5;\n\n\t\tvalues = new Array( kernelSize );\n\t\tsum = 0.0;\n\t\tfor ( i = 0; i < kernelSize; ++ i ) {\n\n\t\t\tvalues[ i ] = gauss( i - halfWidth, sigma );\n\t\t\tsum += values[ i ];\n\n\t\t}\n\n\t\t// normalize the kernel\n\n\t\tfor ( i = 0; i < kernelSize; ++ i ) values[ i ] /= sum;\n\n\t\treturn values;\n\n\t}\n\n};\n"]}