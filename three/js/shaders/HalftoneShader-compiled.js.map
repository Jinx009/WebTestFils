{"version":3,"sources":["HalftoneShader.js"],"names":[],"mappings":"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","file":"HalftoneShader-compiled.js","sourcesContent":["console.warn( \"THREE.HalftoneShader: As part of the transition to ES6 Modules, the files in 'examples/js' were deprecated in May 2020 (r117) and will be deleted in December 2020 (r124). You can find more information about developing using ES6 Modules in https://threejs.org/docs/#manual/en/introduction/Installation.\" );\n/**\n * RGB Halftone shader for three.js.\n *\tNOTE:\n * \t\tShape (1 = Dot, 2 = Ellipse, 3 = Line, 4 = Square)\n *\t\tBlending Mode (1 = Linear, 2 = Multiply, 3 = Add, 4 = Lighter, 5 = Darker)\n */\n\nTHREE.HalftoneShader = {\n\n\tuniforms: {\n\t\t\"tDiffuse\": { value: null },\n\t\t\"shape\": { value: 1 },\n\t\t\"radius\": { value: 4 },\n\t\t\"rotateR\": { value: Math.PI / 12 * 1 },\n\t\t\"rotateG\": { value: Math.PI / 12 * 2 },\n\t\t\"rotateB\": { value: Math.PI / 12 * 3 },\n\t\t\"scatter\": { value: 0 },\n\t\t\"width\": { value: 1 },\n\t\t\"height\": { value: 1 },\n\t\t\"blending\": { value: 1 },\n\t\t\"blendingMode\": { value: 1 },\n\t\t\"greyscale\": { value: false },\n\t\t\"disable\": { value: false }\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUV;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUV = uv;\",\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"#define SQRT2_MINUS_ONE 0.41421356\",\n\t\t\"#define SQRT2_HALF_MINUS_ONE 0.20710678\",\n\t\t\"#define PI2 6.28318531\",\n\t\t\"#define SHAPE_DOT 1\",\n\t\t\"#define SHAPE_ELLIPSE 2\",\n\t\t\"#define SHAPE_LINE 3\",\n\t\t\"#define SHAPE_SQUARE 4\",\n\t\t\"#define BLENDING_LINEAR 1\",\n\t\t\"#define BLENDING_MULTIPLY 2\",\n\t\t\"#define BLENDING_ADD 3\",\n\t\t\"#define BLENDING_LIGHTER 4\",\n\t\t\"#define BLENDING_DARKER 5\",\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform float radius;\",\n\t\t\"uniform float rotateR;\",\n\t\t\"uniform float rotateG;\",\n\t\t\"uniform float rotateB;\",\n\t\t\"uniform float scatter;\",\n\t\t\"uniform float width;\",\n\t\t\"uniform float height;\",\n\t\t\"uniform int shape;\",\n\t\t\"uniform bool disable;\",\n\t\t\"uniform float blending;\",\n\t\t\"uniform int blendingMode;\",\n\t\t\"varying vec2 vUV;\",\n\t\t\"uniform bool greyscale;\",\n\t\t\"const int samples = 8;\",\n\n\t\t\"float blend( float a, float b, float t ) {\",\n\n\t\t// linear blend\n\t\t\"\treturn a * ( 1.0 - t ) + b * t;\",\n\n\t\t\"}\",\n\n\t\t\"float hypot( float x, float y ) {\",\n\n\t\t// vector magnitude\n\t\t\"\treturn sqrt( x * x + y * y );\",\n\n\t\t\"}\",\n\n\t\t\"float rand( vec2 seed ){\",\n\n\t\t// get pseudo-random number\n\t    \"return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\",\n\n\t\t\"}\",\n\n\t\t\"float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {\",\n\n\t\t// apply shape-specific transforms\n\t\t\"\tfloat dist = hypot( coord.x - p.x, coord.y - p.y );\",\n\t\t\"\tfloat rad = channel;\",\n\n\t\t\"\tif ( shape == SHAPE_DOT ) {\",\n\n\t\t\"\t\trad = pow( abs( rad ), 1.125 ) * rad_max;\",\n\n\t\t\"\t} else if ( shape == SHAPE_ELLIPSE ) {\",\n\n\t\t\"\t\trad = pow( abs( rad ), 1.125 ) * rad_max;\",\n\n\t\t\"\t\tif ( dist != 0.0 ) {\",\n\t\t\"\t\t\tfloat dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );\",\n\t\t\"\t\t\tdist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;\",\n\t\t\"\t\t}\",\n\n\t\t\"\t} else if ( shape == SHAPE_LINE ) {\",\n\n\t\t\"\t\trad = pow( abs( rad ), 1.5) * rad_max;\",\n\t\t\"\t\tfloat dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;\",\n\t\t\"\t\tdist = hypot( normal.x * dot_p, normal.y * dot_p );\",\n\n\t\t\"\t} else if ( shape == SHAPE_SQUARE ) {\",\n\n\t\t\"\t\tfloat theta = atan( p.y - coord.y, p.x - coord.x ) - angle;\",\n\t\t\"\t\tfloat sin_t = abs( sin( theta ) );\",\n\t\t\"\t\tfloat cos_t = abs( cos( theta ) );\",\n\t\t\"\t\trad = pow( abs( rad ), 1.4 );\",\n\t\t\"\t\trad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );\",\n\n\t\t\"\t}\",\n\n\t\t\"\treturn rad - dist;\",\n\n\t\t\"}\",\n\n\t\t\"struct Cell {\",\n\n\t\t// grid sample positions\n\t\t\"\tvec2 normal;\",\n\t\t\"\tvec2 p1;\",\n\t\t\"\tvec2 p2;\",\n\t\t\"\tvec2 p3;\",\n\t\t\"\tvec2 p4;\",\n\t\t\"\tfloat samp2;\",\n\t\t\"\tfloat samp1;\",\n\t\t\"\tfloat samp3;\",\n\t\t\"\tfloat samp4;\",\n\n\t\t\"};\",\n\n\t\t\"vec4 getSample( vec2 point ) {\",\n\n\t\t// multi-sampled point\n\t\t\"\tvec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );\",\n\t\t\"\tfloat base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;\",\n\t\t\"\tfloat step = PI2 / float( samples );\",\n\t\t\"\tfloat dist = radius * 0.66;\",\n\n\t\t\"\tfor ( int i = 0; i < samples; ++i ) {\",\n\n\t\t\"\t\tfloat r = base + step * float( i );\",\n\t\t\"\t\tvec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );\",\n\t\t\"\t\ttex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );\",\n\n\t\t\"\t}\",\n\n\t\t\"\ttex /= float( samples ) + 1.0;\",\n\t\t\"\treturn tex;\",\n\n\t\t\"}\",\n\n\t\t\"float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {\",\n\n\t\t// get colour for given point\n\t\t\"\tfloat dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;\",\n\n\t\t\"\tif ( channel == 0 ) {\",\n\n\t\t\"\t\tc.samp1 = getSample( c.p1 ).r;\",\n\t\t\"\t\tc.samp2 = getSample( c.p2 ).r;\",\n\t\t\"\t\tc.samp3 = getSample( c.p3 ).r;\",\n\t\t\"\t\tc.samp4 = getSample( c.p4 ).r;\",\n\n\t\t\"\t} else if (channel == 1) {\",\n\n\t\t\"\t\tc.samp1 = getSample( c.p1 ).g;\",\n\t\t\"\t\tc.samp2 = getSample( c.p2 ).g;\",\n\t\t\"\t\tc.samp3 = getSample( c.p3 ).g;\",\n\t\t\"\t\tc.samp4 = getSample( c.p4 ).g;\",\n\n\t\t\"\t} else {\",\n\n\t\t\"\t\tc.samp1 = getSample( c.p1 ).b;\",\n\t\t\"\t\tc.samp3 = getSample( c.p3 ).b;\",\n\t\t\"\t\tc.samp2 = getSample( c.p2 ).b;\",\n\t\t\"\t\tc.samp4 = getSample( c.p4 ).b;\",\n\n\t\t\"\t}\",\n\n\t\t\"\tdist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );\",\n\t\t\"\tdist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );\",\n\t\t\"\tdist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );\",\n\t\t\"\tdist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );\",\n\t\t\"\tres = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;\",\n\t\t\"\tres += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;\",\n\t\t\"\tres += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;\",\n\t\t\"\tres += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;\",\n\t\t\"\tres = clamp( res, 0.0, 1.0 );\",\n\n\t\t\"\treturn res;\",\n\n\t\t\"}\",\n\n\t\t\"Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {\",\n\n\t\t// get containing cell\n\t\t\"\tCell c;\",\n\n\t\t// calc grid\n\t\t\"\tvec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );\",\n\t\t\"\tfloat threshold = step * 0.5;\",\n\t\t\"\tfloat dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );\",\n\t\t\"\tfloat dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );\",\n\t\t\"\tvec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );\",\n\t\t\"\tfloat offset_normal = mod( hypot( offset.x, offset.y ), step );\",\n\t\t\"\tfloat normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;\",\n\t\t\"\tfloat normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;\",\n\t\t\"\tfloat offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );\",\n\t\t\"\tfloat line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;\",\n\t\t\"\tfloat line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;\",\n\n\t\t// get closest corner\n\t\t\"\tc.normal = n;\",\n\t\t\"\tc.p1.x = p.x - n.x * normal_scale + n.y * line_scale;\",\n\t\t\"\tc.p1.y = p.y - n.y * normal_scale - n.x * line_scale;\",\n\n\t\t// scatter\n\t\t\"\tif ( scatter != 0.0 ) {\",\n\n\t\t\"\t\tfloat off_mag = scatter * threshold * 0.5;\",\n\t\t\"\t\tfloat off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;\",\n\t\t\"\t\tc.p1.x += cos( off_angle ) * off_mag;\",\n\t\t\"\t\tc.p1.y += sin( off_angle ) * off_mag;\",\n\n\t\t\"\t}\",\n\n\t\t// find corners\n\t\t\"\tfloat normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );\",\n\t\t\"\tfloat line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );\",\n\t\t\"\tc.p2.x = c.p1.x - n.x * normal_step;\",\n\t\t\"\tc.p2.y = c.p1.y - n.y * normal_step;\",\n\t\t\"\tc.p3.x = c.p1.x + n.y * line_step;\",\n\t\t\"\tc.p3.y = c.p1.y - n.x * line_step;\",\n\t\t\"\tc.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;\",\n\t\t\"\tc.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;\",\n\n\t\t\"\treturn c;\",\n\n\t\t\"}\",\n\n\t\t\"float blendColour( float a, float b, float t ) {\",\n\n\t\t// blend colours\n\t\t\"\tif ( blendingMode == BLENDING_LINEAR ) {\",\n\t\t\"\t\treturn blend( a, b, 1.0 - t );\",\n\t\t\"\t} else if ( blendingMode == BLENDING_ADD ) {\",\n\t\t\"\t\treturn blend( a, min( 1.0, a + b ), t );\",\n\t\t\"\t} else if ( blendingMode == BLENDING_MULTIPLY ) {\",\n\t\t\"\t\treturn blend( a, max( 0.0, a * b ), t );\",\n\t\t\"\t} else if ( blendingMode == BLENDING_LIGHTER ) {\",\n\t\t\"\t\treturn blend( a, max( a, b ), t );\",\n\t\t\"\t} else if ( blendingMode == BLENDING_DARKER ) {\",\n\t\t\"\t\treturn blend( a, min( a, b ), t );\",\n\t\t\"\t} else {\",\n\t\t\"\t\treturn blend( a, b, 1.0 - t );\",\n\t\t\"\t}\",\n\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tif ( ! disable ) {\",\n\n\t\t// setup\n\t\t\"\t\tvec2 p = vec2( vUV.x * width, vUV.y * height );\",\n\t\t\"\t\tvec2 origin = vec2( 0, 0 );\",\n\t\t\"\t\tfloat aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;\",\n\n\t\t// get channel samples\n\t\t\"\t\tCell cell_r = getReferenceCell( p, origin, rotateR, radius );\",\n\t\t\"\t\tCell cell_g = getReferenceCell( p, origin, rotateG, radius );\",\n\t\t\"\t\tCell cell_b = getReferenceCell( p, origin, rotateB, radius );\",\n\t\t\"\t\tfloat r = getDotColour( cell_r, p, 0, rotateR, aa );\",\n\t\t\"\t\tfloat g = getDotColour( cell_g, p, 1, rotateG, aa );\",\n\t\t\"\t\tfloat b = getDotColour( cell_b, p, 2, rotateB, aa );\",\n\n\t\t// blend with original\n\t\t\"\t\tvec4 colour = texture2D( tDiffuse, vUV );\",\n\t\t\"\t\tr = blendColour( r, colour.r, blending );\",\n\t\t\"\t\tg = blendColour( g, colour.g, blending );\",\n\t\t\"\t\tb = blendColour( b, colour.b, blending );\",\n\n\t\t\"\t\tif ( greyscale ) {\",\n\t\t\"\t\t\tr = g = b = (r + b + g) / 3.0;\",\n\t\t\"\t\t}\",\n\n\t\t\"\t\tgl_FragColor = vec4( r, g, b, 1.0 );\",\n\n\t\t\"\t} else {\",\n\n\t\t\"\t\tgl_FragColor = texture2D( tDiffuse, vUV );\",\n\n\t\t\"\t}\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n"]}