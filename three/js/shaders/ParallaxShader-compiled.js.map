{"version":3,"sources":["ParallaxShader.js"],"names":[],"mappings":"AAAA,QAAQ,IAAR,CAAc,+SAAd;AACA;AACA;AACA;AACA;;AAEA,MAAM,cAAN,GAAuB;AACtB;AACA,QAAO;AACN,QAAM,aADA;AAEN,SAAO,oBAFD;AAGN,SAAO,oBAHD;AAIN,aAAW,uBAJL,EAI8B;AACpC,UAAQ;AALF,EAFe;;AAUtB,WAAU;AACT,aAAW,EAAE,OAAO,IAAT,EADF;AAET,SAAO,EAAE,OAAO,IAAT,EAFE;AAGT,mBAAiB,EAAE,OAAO,IAAT,EAHR;AAIT,uBAAqB,EAAE,OAAO,IAAT,EAJZ;AAKT,uBAAqB,EAAE,OAAO,IAAT;AALZ,EAVY;;AAkBtB,eAAc,CACb,mBADa,EAEb,6BAFa,EAGb,uBAHa,EAKb,eALa,EAOb,YAPa,EAQb,6DARa,EASb,mCATa,EAUb,gDAVa,EAWb,+CAXa,EAab,GAba,EAeZ,IAfY,CAeN,IAfM,CAlBQ;;AAmCtB,iBAAgB,CACf,4BADe,EAEf,wBAFe,EAIf,8BAJe,EAKf,kCALe,EAMf,kCANe,EAQf,mBARe,EASf,6BATe,EAUf,uBAVe,EAYf,2BAZe,EAcf,kCAde,EAgBf,sDAhBe;;AAkBf;AACA;;AAEA;AACA,gEAtBe,EAuBf,gCAvBe,EAyBf,IAzBe,EA2Bf,OA3Be,EA6Bf,kCA7Be;;AA+Bf;AACA,2GAhCe,EAkCf,wCAlCe,EAmCf,mCAnCe;AAoCf;AACA,wDArCe,EAuCf,oCAvCe,EAyCf,2EAzCe;;AA2Cf;AACA;AACA;AACA,wCA9Ce,EA+Cf,qDA/Ce,EAgDf,YAhDe,EAiDf,MAjDe,EAkDf,uCAlDe;AAmDf;AACA,mCApDe,EAqDf,sEArDe,EAsDf,KAtDe,EAwDf,6BAxDe,EA0Df,iCA1De,EA4Df,wCA5De,EA8Df,qCA9De,EA+Df,2CA/De;;AAiEf;AACA,4CAlEe,EAmEf,uCAnEe;;AAqEf;AACA,gCAtEe,EAuEf,iDAvEe,EAyEf,2BAzEe,EA0Ef,yBA1Ee,EA2Ef,uEA3Ee;AA4Ef;AACA,qDA7Ee,EA6EuC;;AAEtD,8CA/Ee,EAgFf,yCAhFe,EAkFf,cAlFe,EAkFC;;AAEhB,8CApFe,EAqFf,yCArFe,EAuFf,OAvFe,EAyFf,MAzFe,EA0Ff,iCA1Fe,EA4Ff,0CA5Fe,EA8Ff,oDA9Fe;;AAgGf;AACA,2DAjGe,EAkGf,0FAlGe;;AAoGf;AACA,+CArGe;;AAuGf;AACA,4EAxGe,EA0Gf,SA1Ge,EA0GJ;;AAEX,iBA5Ge,EA8Gf,UA9Ge,EAgHf,IAhHe,EAiHf,QAjHe,EAmHf,2EAnHe,EAqHd,4BArHc,EAsHf,4BAtHe,EAwHf,uCAxHe,EAyHf,uCAzHe,EA0Hf,2CA1He,EA2Hf,2CA3He,EA4Hf,oCA5He,EA8Hf,gGA9He,EA+Hf,kBA/He,EAgIf,4DAhIe,EAiIf,iDAjIe,EAmIf,mCAnIe,EAoIf,GApIe,EAsIf,eAtIe,EAwIf,8FAxIe,EAyIf,0CAzIe,EA2If,GA3Ie,EA6Id,IA7Ic,CA6IR,IA7IQ;;AAnCM,CAAvB","file":"ParallaxShader-compiled.js","sourcesContent":["console.warn( \"THREE.ParallaxShader: As part of the transition to ES6 Modules, the files in 'examples/js' were deprecated in May 2020 (r117) and will be deleted in December 2020 (r124). You can find more information about developing using ES6 Modules in https://threejs.org/docs/#manual/en/introduction/Installation.\" );\n// Parallax Occlusion shaders from\n//    http://sunandblackcat.com/tipFullView.php?topicid=28\n// No tangent-space transforms logic based on\n//   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html\n\nTHREE.ParallaxShader = {\n\t// Ordered from fastest to best quality.\n\tmodes: {\n\t\tnone: \"NO_PARALLAX\",\n\t\tbasic: \"USE_BASIC_PARALLAX\",\n\t\tsteep: \"USE_STEEP_PARALLAX\",\n\t\tocclusion: \"USE_OCLUSION_PARALLAX\", // a.k.a. POM\n\t\trelief: \"USE_RELIEF_PARALLAX\"\n\t},\n\n\tuniforms: {\n\t\t\"bumpMap\": { value: null },\n\t\t\"map\": { value: null },\n\t\t\"parallaxScale\": { value: null },\n\t\t\"parallaxMinLayers\": { value: null },\n\t\t\"parallaxMaxLayers\": { value: null }\n\t},\n\n\tvertexShader: [\n\t\t\"varying vec2 vUv;\",\n\t\t\"varying vec3 vViewPosition;\",\n\t\t\"varying vec3 vNormal;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv;\",\n\t\t\"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\"\tvViewPosition = -mvPosition.xyz;\",\n\t\t\"\tvNormal = normalize( normalMatrix * normal );\",\n\t\t\"\tgl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\t\t\"uniform sampler2D bumpMap;\",\n\t\t\"uniform sampler2D map;\",\n\n\t\t\"uniform float parallaxScale;\",\n\t\t\"uniform float parallaxMinLayers;\",\n\t\t\"uniform float parallaxMaxLayers;\",\n\n\t\t\"varying vec2 vUv;\",\n\t\t\"varying vec3 vViewPosition;\",\n\t\t\"varying vec3 vNormal;\",\n\n\t\t\"#ifdef USE_BASIC_PARALLAX\",\n\n\t\t\"\tvec2 parallaxMap( in vec3 V ) {\",\n\n\t\t\"\t\tfloat initialHeight = texture2D( bumpMap, vUv ).r;\",\n\n\t\t// No Offset Limitting: messy, floating output at grazing angles.\n\t\t//\"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\",\n\n\t\t// Offset Limiting\n\t\t\"\t\tvec2 texCoordOffset = parallaxScale * V.xy * initialHeight;\",\n\t\t\"\t\treturn vUv - texCoordOffset;\",\n\n\t\t\"\t}\",\n\n\t\t\"#else\",\n\n\t\t\"\tvec2 parallaxMap( in vec3 V ) {\",\n\n\t\t// Determine number of layers from angle between V and N\n\t\t\"\t\tfloat numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );\",\n\n\t\t\"\t\tfloat layerHeight = 1.0 / numLayers;\",\n\t\t\"\t\tfloat currentLayerHeight = 0.0;\",\n\t\t// Shift of texture coordinates for each iteration\n\t\t\"\t\tvec2 dtex = parallaxScale * V.xy / V.z / numLayers;\",\n\n\t\t\"\t\tvec2 currentTextureCoords = vUv;\",\n\n\t\t\"\t\tfloat heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\n\n\t\t// while ( heightFromTexture > currentLayerHeight )\n\t\t// Infinite loops are not well supported. Do a \"large\" finite\n\t\t// loop, but not too large, as it slows down some compilers.\n\t\t\"\t\tfor ( int i = 0; i < 30; i += 1 ) {\",\n\t\t\"\t\t\tif ( heightFromTexture <= currentLayerHeight ) {\",\n\t\t\"\t\t\t\tbreak;\",\n\t\t\"\t\t\t}\",\n\t\t\"\t\t\tcurrentLayerHeight += layerHeight;\",\n\t\t// Shift texture coordinates along vector V\n\t\t\"\t\t\tcurrentTextureCoords -= dtex;\",\n\t\t\"\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\n\t\t\"\t\t}\",\n\n\t\t\"\t\t#ifdef USE_STEEP_PARALLAX\",\n\n\t\t\"\t\t\treturn currentTextureCoords;\",\n\n\t\t\"\t\t#elif defined( USE_RELIEF_PARALLAX )\",\n\n\t\t\"\t\t\tvec2 deltaTexCoord = dtex / 2.0;\",\n\t\t\"\t\t\tfloat deltaHeight = layerHeight / 2.0;\",\n\n\t\t// Return to the mid point of previous layer\n\t\t\"\t\t\tcurrentTextureCoords += deltaTexCoord;\",\n\t\t\"\t\t\tcurrentLayerHeight -= deltaHeight;\",\n\n\t\t// Binary search to increase precision of Steep Parallax Mapping\n\t\t\"\t\t\tconst int numSearches = 5;\",\n\t\t\"\t\t\tfor ( int i = 0; i < numSearches; i += 1 ) {\",\n\n\t\t\"\t\t\t\tdeltaTexCoord /= 2.0;\",\n\t\t\"\t\t\t\tdeltaHeight /= 2.0;\",\n\t\t\"\t\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\n\t\t// Shift along or against vector V\n\t\t\"\t\t\t\tif( heightFromTexture > currentLayerHeight ) {\", // Below the surface\n\n\t\t\"\t\t\t\t\tcurrentTextureCoords -= deltaTexCoord;\",\n\t\t\"\t\t\t\t\tcurrentLayerHeight += deltaHeight;\",\n\n\t\t\"\t\t\t\t} else {\", // above the surface\n\n\t\t\"\t\t\t\t\tcurrentTextureCoords += deltaTexCoord;\",\n\t\t\"\t\t\t\t\tcurrentLayerHeight -= deltaHeight;\",\n\n\t\t\"\t\t\t\t}\",\n\n\t\t\"\t\t\t}\",\n\t\t\"\t\t\treturn currentTextureCoords;\",\n\n\t\t\"\t\t#elif defined( USE_OCLUSION_PARALLAX )\",\n\n\t\t\"\t\t\tvec2 prevTCoords = currentTextureCoords + dtex;\",\n\n\t\t// Heights for linear interpolation\n\t\t\"\t\t\tfloat nextH = heightFromTexture - currentLayerHeight;\",\n\t\t\"\t\t\tfloat prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;\",\n\n\t\t// Proportions for linear interpolation\n\t\t\"\t\t\tfloat weight = nextH / ( nextH - prevH );\",\n\n\t\t// Interpolation of texture coordinates\n\t\t\"\t\t\treturn prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );\",\n\n\t\t\"\t\t#else\", // NO_PARALLAX\n\n\t\t\"\t\t\treturn vUv;\",\n\n\t\t\"\t\t#endif\",\n\n\t\t\"\t}\",\n\t\t\"#endif\",\n\n\t\t\"vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {\",\n\n \t\t\"\tvec2 texDx = dFdx( vUv );\",\n\t\t\"\tvec2 texDy = dFdy( vUv );\",\n\n\t\t\"\tvec3 vSigmaX = dFdx( surfPosition );\",\n\t\t\"\tvec3 vSigmaY = dFdy( surfPosition );\",\n\t\t\"\tvec3 vR1 = cross( vSigmaY, surfNormal );\",\n\t\t\"\tvec3 vR2 = cross( surfNormal, vSigmaX );\",\n\t\t\"\tfloat fDet = dot( vSigmaX, vR1 );\",\n\n\t\t\"\tvec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );\",\n\t\t\"\tvec3 vProjVtex;\",\n\t\t\"\tvProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;\",\n\t\t\"\tvProjVtex.z = dot( surfNormal, viewPosition );\",\n\n\t\t\"\treturn parallaxMap( vProjVtex );\",\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );\",\n\t\t\"\tgl_FragColor = texture2D( map, mapUv );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n"]}