{"version":3,"sources":["SSAOShader.js"],"names":[],"mappings":"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","file":"SSAOShader-compiled.js","sourcesContent":["console.warn( \"THREE.SSAOShader: As part of the transition to ES6 Modules, the files in 'examples/js' were deprecated in May 2020 (r117) and will be deleted in December 2020 (r124). You can find more information about developing using ES6 Modules in https://threejs.org/docs/#manual/en/introduction/Installation.\" );\n/**\n * References:\n * http://john-chapman-graphics.blogspot.com/2013/01/ssao-tutorial.html\n * https://learnopengl.com/Advanced-Lighting/SSAO\n * https://github.com/McNopper/OpenGL/blob/master/Example28/shader/ssao.frag.glsl\n */\n\nTHREE.SSAOShader = {\n\n\tdefines: {\n\t\t\"PERSPECTIVE_CAMERA\": 1,\n\t\t\"KERNEL_SIZE\": 32\n\t},\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"tNormal\": { value: null },\n\t\t\"tDepth\": { value: null },\n\t\t\"tNoise\": { value: null },\n\t\t\"kernel\": { value: null },\n\t\t\"cameraNear\": { value: null },\n\t\t\"cameraFar\": { value: null },\n\t\t\"resolution\": { value: new THREE.Vector2() },\n\t\t\"cameraProjectionMatrix\": { value: new THREE.Matrix4() },\n\t\t\"cameraInverseProjectionMatrix\": { value: new THREE.Matrix4() },\n\t\t\"kernelRadius\": { value: 8 },\n\t\t\"minDistance\": { value: 0.005 },\n\t\t\"maxDistance\": { value: 0.05 },\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv;\",\n\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform sampler2D tNormal;\",\n\t\t\"uniform sampler2D tDepth;\",\n\t\t\"uniform sampler2D tNoise;\",\n\n\t\t\"uniform vec3 kernel[ KERNEL_SIZE ];\",\n\n\t\t\"uniform vec2 resolution;\",\n\n\t\t\"uniform float cameraNear;\",\n\t\t\"uniform float cameraFar;\",\n\t\t\"uniform mat4 cameraProjectionMatrix;\",\n\t\t\"uniform mat4 cameraInverseProjectionMatrix;\",\n\n\t\t\"uniform float kernelRadius;\",\n\t\t\"uniform float minDistance;\", // avoid artifacts caused by neighbour fragments with minimal depth difference\n\t\t\"uniform float maxDistance;\", // avoid the influence of fragments which are too far away\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"#include <packing>\",\n\n\t\t\"float getDepth( const in vec2 screenPosition ) {\",\n\n\t\t\"\treturn texture2D( tDepth, screenPosition ).x;\",\n\n\t\t\"}\",\n\n\t\t\"float getLinearDepth( const in vec2 screenPosition ) {\",\n\n\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\n\t\t\"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\",\n\t\t\"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\",\n\t\t\"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\",\n\n\t\t\"\t#else\",\n\n\t\t\"\t\treturn texture2D( depthSampler, coord ).x;\",\n\n\t\t\"\t#endif\",\n\n\t\t\"}\",\n\n\t\t\"float getViewZ( const in float depth ) {\",\n\n\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\n\t\t\"\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\",\n\n\t\t\"\t#else\",\n\n\t\t\"\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\",\n\n\t\t\"\t#endif\",\n\n\t\t\"}\",\n\n\t\t\"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\",\n\n\t\t\"\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\",\n\n\t\t\"\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\",\n\n\t\t\"\tclipPosition *= clipW; // unprojection.\",\n\n\t\t\"\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\",\n\n\t\t\"}\",\n\n\t\t\"vec3 getViewNormal( const in vec2 screenPosition ) {\",\n\n\t\t\"\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\",\n\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tfloat depth = getDepth( vUv );\",\n\t\t\"\tfloat viewZ = getViewZ( depth );\",\n\n\t\t\"\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\",\n\t\t\"\tvec3 viewNormal = getViewNormal( vUv );\",\n\n\t\t\" vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\",\n\t\t\"\tvec3 random = texture2D( tNoise, vUv * noiseScale ).xyz;\",\n\n\t\t// compute matrix used to reorient a kernel vector\n\n\t\t\"\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\",\n\t\t\"\tvec3 bitangent = cross( viewNormal, tangent );\",\n\t\t\"\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\",\n\n\t\t\" float occlusion = 0.0;\",\n\n\t\t\" for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\",\n\n\t\t\"\t\tvec3 sampleVector = kernelMatrix * kernel[ i ];\", // reorient sample vector in view space\n\t\t\"\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius );\", // calculate sample point\n\n\t\t\"\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );\", // project point and calculate NDC\n\t\t\"\t\tsamplePointNDC /= samplePointNDC.w;\",\n\n\t\t\"\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5;\", // compute uv coordinates\n\n\t\t\"\t\tfloat realDepth = getLinearDepth( samplePointUv );\", // get linear depth from depth texture\n\t\t\"\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );\", // compute linear depth of the sample view Z value\n\t\t\"\t\tfloat delta = sampleDepth - realDepth;\",\n\n\t\t\"\t\tif ( delta > minDistance && delta < maxDistance ) {\", // if fragment is before sample point, increase occlusion\n\n\t\t\"\t\t\tocclusion += 1.0;\",\n\n\t\t\"\t\t}\",\n\n\t\t\"\t}\",\n\n\t\t\"\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\",\n\n\t\t\"\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n\nTHREE.SSAODepthShader = {\n\n\tdefines: {\n\t\t\"PERSPECTIVE_CAMERA\": 1\n\t},\n\n\tuniforms: {\n\n\t\t\"tDepth\": { value: null },\n\t\t\"cameraNear\": { value: null },\n\t\t\"cameraFar\": { value: null },\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv;\",\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\"uniform float cameraNear;\",\n\t\t\"uniform float cameraFar;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"#include <packing>\",\n\n\t\t\"float getLinearDepth( const in vec2 screenPosition ) {\",\n\n\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\n\t\t\"\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\",\n\t\t\"\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\",\n\t\t\"\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\",\n\n\t\t\"\t#else\",\n\n\t\t\"\t\treturn texture2D( depthSampler, coord ).x;\",\n\n\t\t\"\t#endif\",\n\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tfloat depth = getLinearDepth( vUv );\",\n\t\t\"\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n\nTHREE.SSAOBlurShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"resolution\": { value: new THREE.Vector2() }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv;\",\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"uniform vec2 resolution;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvec2 texelSize = ( 1.0 / resolution );\",\n\t\t\"\tfloat result = 0.0;\",\n\n\t\t\"\tfor ( int i = - 2; i <= 2; i ++ ) {\",\n\n\t\t\"\t\tfor ( int j = - 2; j <= 2; j ++ ) {\",\n\n\t\t\"\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\",\n\t\t\"\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\",\n\n\t\t\"\t\t}\",\n\n\t\t\"\t}\",\n\n\t\t\"\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n"]}