{"version":3,"sources":["OceanShaders.js"],"names":[],"mappings":"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","file":"OceanShaders-compiled.js","sourcesContent":["console.warn( \"THREE.OceanShaders: As part of the transition to ES6 Modules, the files in 'examples/js' were deprecated in May 2020 (r117) and will be deleted in December 2020 (r124). You can find more information about developing using ES6 Modules in https://threejs.org/docs/#manual/en/introduction/Installation.\" );\n\n// Description: A deep water ocean shader set\n// based on an implementation of a Tessendorf Waves\n// originally presented by David Li ( www.david.li/waves )\n\n// The general method is to apply shaders to simulation Framebuffers\n// and then sample these framebuffers when rendering the ocean mesh\n\n// The set uses 7 shaders:\n\n// -- Simulation shaders\n// [1] ocean_sim_vertex         -> Vertex shader used to set up a 2x2 simulation plane centered at (0,0)\n// [2] ocean_subtransform       -> Fragment shader used to subtransform the mesh (generates the displacement map)\n// [3] ocean_initial_spectrum   -> Fragment shader used to set intitial wave frequency at a texel coordinate\n// [4] ocean_phase              -> Fragment shader used to set wave phase at a texel coordinate\n// [5] ocean_spectrum           -> Fragment shader used to set current wave frequency at a texel coordinate\n// [6] ocean_normal             -> Fragment shader used to set face normals at a texel coordinate\n\n// -- Rendering Shader\n// [7] ocean_main               -> Vertex and Fragment shader used to create the final render\n\nTHREE.OceanShaders = {};\nTHREE.OceanShaders[ \"ocean_sim_vertex\" ] = {\n\tvertexShader: [\n\t\t\"varying vec2 vUV;\",\n\n\t\t\"void main (void) {\",\n\t\t\"\tvUV = position.xy * 0.5 + 0.5;\",\n\t\t\"\tgl_Position = vec4(position, 1.0 );\",\n\t\t\"}\"\n\t].join( \"\\n\" )\n};\nTHREE.OceanShaders[ \"ocean_subtransform\" ] = {\n\tuniforms: {\n\t\t\"u_input\": { value: null },\n\t\t\"u_transformSize\": { value: 512.0 },\n\t\t\"u_subtransformSize\": { value: 250.0 }\n\t},\n\tfragmentShader: [\n\t\t//GPU FFT using a Stockham formulation\n\n\t\t\"precision highp float;\",\n\t\t\"#include <common>\",\n\n\t\t\"uniform sampler2D u_input;\",\n\t\t\"uniform float u_transformSize;\",\n\t\t\"uniform float u_subtransformSize;\",\n\n\t\t\"varying vec2 vUV;\",\n\n\t\t\"vec2 multiplyComplex (vec2 a, vec2 b) {\",\n\t\t\"\treturn vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);\",\n\t\t\"}\",\n\n\t\t\"void main (void) {\",\n\t\t\"\t#ifdef HORIZONTAL\",\n\t\t\"\tfloat index = vUV.x * u_transformSize - 0.5;\",\n\t\t\"\t#else\",\n\t\t\"\tfloat index = vUV.y * u_transformSize - 0.5;\",\n\t\t\"\t#endif\",\n\n\t\t\"\tfloat evenIndex = floor(index / u_subtransformSize) * (u_subtransformSize * 0.5) + mod(index, u_subtransformSize * 0.5);\",\n\n\t\t//transform two complex sequences simultaneously\n\t\t\"\t#ifdef HORIZONTAL\",\n\t\t\"\tvec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / u_transformSize).rgba;\",\n\t\t\"\tvec4 odd = texture2D(u_input, vec2(evenIndex + u_transformSize * 0.5 + 0.5, gl_FragCoord.y) / u_transformSize).rgba;\",\n\t\t\"\t#else\",\n\t\t\"\tvec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / u_transformSize).rgba;\",\n\t\t\"\tvec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + u_transformSize * 0.5 + 0.5) / u_transformSize).rgba;\",\n\t\t\"\t#endif\",\n\n\t\t\"\tfloat twiddleArgument = -2.0 * PI * (index / u_subtransformSize);\",\n\t\t\"\tvec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));\",\n\n\t\t\"\tvec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);\",\n\t\t\"\tvec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);\",\n\n\t\t\"\tgl_FragColor = vec4(outputA, outputB);\",\n\t\t\"}\"\n\t].join( \"\\n\" )\n};\nTHREE.OceanShaders[ \"ocean_initial_spectrum\" ] = {\n\tuniforms: {\n\t\t\"u_wind\": { value: new THREE.Vector2( 10.0, 10.0 ) },\n\t\t\"u_resolution\": { value: 512.0 },\n\t\t\"u_size\": { value: 250.0 }\n\t},\n\tvertexShader: [\n\t\t\"void main (void) {\",\n\t\t\"\tgl_Position = vec4(position, 1.0);\",\n\t\t\"}\"\n\t].join( \"\\n\" ),\n\tfragmentShader: [\n\t\t\"precision highp float;\",\n\t\t\"#include <common>\",\n\n\t\t\"const float G = 9.81;\",\n\t\t\"const float KM = 370.0;\",\n\t\t\"const float CM = 0.23;\",\n\n\t\t\"uniform vec2 u_wind;\",\n\t\t\"uniform float u_resolution;\",\n\t\t\"uniform float u_size;\",\n\n\t\t\"float omega (float k) {\",\n\t\t\"\treturn sqrt(G * k * (1.0 + pow2(k / KM)));\",\n\t\t\"}\",\n\n\t\t\"#if __VERSION__ == 100\",\n\t\t\"float tanh (float x) {\",\n\t\t\"\treturn (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));\",\n\t\t\"}\",\n\t\t\"#endif\",\n\n\t\t\"void main (void) {\",\n\t\t\"\tvec2 coordinates = gl_FragCoord.xy - 0.5;\",\n\n\t\t\"\tfloat n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;\",\n\t\t\"\tfloat m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;\",\n\n\t\t\"\tvec2 K = (2.0 * PI * vec2(n, m)) / u_size;\",\n\t\t\"\tfloat k = length(K);\",\n\n\t\t\"\tfloat l_wind = length(u_wind);\",\n\n\t\t\"\tfloat Omega = 0.84;\",\n\t\t\"\tfloat kp = G * pow2(Omega / l_wind);\",\n\n\t\t\"\tfloat c = omega(k) / k;\",\n\t\t\"\tfloat cp = omega(kp) / kp;\",\n\n\t\t\"\tfloat Lpm = exp(-1.25 * pow2(kp / k));\",\n\t\t\"\tfloat gamma = 1.7;\",\n\t\t\"\tfloat sigma = 0.08 * (1.0 + 4.0 * pow(Omega, -3.0));\",\n\t\t\"\tfloat Gamma = exp(-pow2(sqrt(k / kp) - 1.0) / 2.0 * pow2(sigma));\",\n\t\t\"\tfloat Jp = pow(gamma, Gamma);\",\n\t\t\"\tfloat Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));\",\n\t\t\"\tfloat alphap = 0.006 * sqrt(Omega);\",\n\t\t\"\tfloat Bl = 0.5 * alphap * cp / c * Fp;\",\n\n\t\t\"\tfloat z0 = 0.000037 * pow2(l_wind) / G * pow(l_wind / cp, 0.9);\",\n\t\t\"\tfloat uStar = 0.41 * l_wind / log(10.0 / z0);\",\n\t\t\"\tfloat alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));\",\n\t\t\"\tfloat Fm = exp(-0.25 * pow2(k / KM - 1.0));\",\n\t\t\"\tfloat Bh = 0.5 * alpham * CM / c * Fm * Lpm;\",\n\n\t\t\"\tfloat a0 = log(2.0) / 4.0;\",\n\t\t\"\tfloat am = 0.13 * uStar / CM;\",\n\t\t\"\tfloat Delta = tanh(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));\",\n\n\t\t\"\tfloat cosPhi = dot(normalize(u_wind), normalize(K));\",\n\n\t\t\"\tfloat S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));\",\n\n\t\t\"\tfloat dk = 2.0 * PI / u_size;\",\n\t\t\"\tfloat h = sqrt(S / 2.0) * dk;\",\n\n\t\t\"\tif (K.x == 0.0 && K.y == 0.0) {\",\n\t\t\"\t\th = 0.0;\", //no DC term\n\t\t\"\t}\",\n\t\t\"\tgl_FragColor = vec4(h, 0.0, 0.0, 0.0);\",\n\t\t\"}\"\n\t].join( \"\\n\" )\n};\nTHREE.OceanShaders[ \"ocean_phase\" ] = {\n\tuniforms: {\n\t\t\"u_phases\": { value: null },\n\t\t\"u_deltaTime\": { value: null },\n\t\t\"u_resolution\": { value: null },\n\t\t\"u_size\": { value: null }\n\t},\n\tfragmentShader: [\n\t\t\"precision highp float;\",\n\t\t\"#include <common>\",\n\n\t\t\"const float G = 9.81;\",\n\t\t\"const float KM = 370.0;\",\n\n\t\t\"varying vec2 vUV;\",\n\n\t\t\"uniform sampler2D u_phases;\",\n\t\t\"uniform float u_deltaTime;\",\n\t\t\"uniform float u_resolution;\",\n\t\t\"uniform float u_size;\",\n\n\t\t\"float omega (float k) {\",\n\t\t\"\treturn sqrt(G * k * (1.0 + k * k / KM * KM));\",\n\t\t\"}\",\n\n\t\t\"void main (void) {\",\n\t\t\"\tfloat deltaTime = 1.0 / 60.0;\",\n\t\t\"\tvec2 coordinates = gl_FragCoord.xy - 0.5;\",\n\t\t\"\tfloat n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;\",\n\t\t\"\tfloat m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;\",\n\t\t\"\tvec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;\",\n\n\t\t\"\tfloat phase = texture2D(u_phases, vUV).r;\",\n\t\t\"\tfloat deltaPhase = omega(length(waveVector)) * u_deltaTime;\",\n\t\t\"\tphase = mod(phase + deltaPhase, 2.0 * PI);\",\n\n\t\t\"\tgl_FragColor = vec4(phase, 0.0, 0.0, 0.0);\",\n\t\t\"}\"\n\t].join( \"\\n\" )\n};\nTHREE.OceanShaders[ \"ocean_spectrum\" ] = {\n\tuniforms: {\n\t\t\"u_size\": { value: null },\n\t\t\"u_resolution\": { value: null },\n\t\t\"u_choppiness\": { value: null },\n\t\t\"u_phases\": { value: null },\n\t\t\"u_initialSpectrum\": { value: null }\n\t},\n\tfragmentShader: [\n\t\t\"precision highp float;\",\n\t\t\"#include <common>\",\n\n\t\t\"const float G = 9.81;\",\n\t\t\"const float KM = 370.0;\",\n\n\t\t\"varying vec2 vUV;\",\n\n\t\t\"uniform float u_size;\",\n\t\t\"uniform float u_resolution;\",\n\t\t\"uniform float u_choppiness;\",\n\t\t\"uniform sampler2D u_phases;\",\n\t\t\"uniform sampler2D u_initialSpectrum;\",\n\n\t\t\"vec2 multiplyComplex (vec2 a, vec2 b) {\",\n\t\t\"\treturn vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);\",\n\t\t\"}\",\n\n\t\t\"vec2 multiplyByI (vec2 z) {\",\n\t\t\"\treturn vec2(-z[1], z[0]);\",\n\t\t\"}\",\n\n\t\t\"float omega (float k) {\",\n\t\t\"\treturn sqrt(G * k * (1.0 + k * k / KM * KM));\",\n\t\t\"}\",\n\n\t\t\"void main (void) {\",\n\t\t\"\tvec2 coordinates = gl_FragCoord.xy - 0.5;\",\n\t\t\"\tfloat n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;\",\n\t\t\"\tfloat m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;\",\n\t\t\"\tvec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;\",\n\n\t\t\"\tfloat phase = texture2D(u_phases, vUV).r;\",\n\t\t\"\tvec2 phaseVector = vec2(cos(phase), sin(phase));\",\n\n\t\t\"\tvec2 h0 = texture2D(u_initialSpectrum, vUV).rg;\",\n\t\t\"\tvec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - vUV + 1.0 / u_resolution)).rg;\",\n\t\t\"\th0Star.y *= -1.0;\",\n\n\t\t\"\tvec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));\",\n\n\t\t\"\tvec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;\",\n\t\t\"\tvec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;\",\n\n\t\t//no DC term\n\t\t\"\tif (waveVector.x == 0.0 && waveVector.y == 0.0) {\",\n\t\t\"\t\th = vec2(0.0);\",\n\t\t\"\t\thX = vec2(0.0);\",\n\t\t\"\t\thZ = vec2(0.0);\",\n\t\t\"\t}\",\n\n\t\t\"\tgl_FragColor = vec4(hX + multiplyByI(h), hZ);\",\n\t\t\"}\"\n\t].join( \"\\n\" )\n};\nTHREE.OceanShaders[ \"ocean_normals\" ] = {\n\tuniforms: {\n\t\t\"u_displacementMap\": { value: null },\n\t\t\"u_resolution\": { value: null },\n\t\t\"u_size\": { value: null }\n\t},\n\tfragmentShader: [\n\t\t\"precision highp float;\",\n\n\t\t\"varying vec2 vUV;\",\n\n\t\t\"uniform sampler2D u_displacementMap;\",\n\t\t\"uniform float u_resolution;\",\n\t\t\"uniform float u_size;\",\n\n\t\t\"void main (void) {\",\n\t\t\"\tfloat texel = 1.0 / u_resolution;\",\n\t\t\"\tfloat texelSize = u_size / u_resolution;\",\n\n\t\t\"\tvec3 center = texture2D(u_displacementMap, vUV).rgb;\",\n\t\t\"\tvec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(texel, 0.0)).rgb - center;\",\n\t\t\"\tvec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(-texel, 0.0)).rgb - center;\",\n\t\t\"\tvec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, -texel)).rgb - center;\",\n\t\t\"\tvec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, texel)).rgb - center;\",\n\n\t\t\"\tvec3 topRight = cross(right, top);\",\n\t\t\"\tvec3 topLeft = cross(top, left);\",\n\t\t\"\tvec3 bottomLeft = cross(left, bottom);\",\n\t\t\"\tvec3 bottomRight = cross(bottom, right);\",\n\n\t\t\"\tgl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);\",\n\t\t\"}\"\n\t].join( \"\\n\" )\n};\nTHREE.OceanShaders[ \"ocean_main\" ] = {\n\tuniforms: {\n\t\t\"u_displacementMap\": { value: null },\n\t\t\"u_normalMap\": { value: null },\n\t\t\"u_geometrySize\": { value: null },\n\t\t\"u_size\": { value: null },\n\t\t\"u_projectionMatrix\": { value: null },\n\t\t\"u_viewMatrix\": { value: null },\n\t\t\"u_cameraPosition\": { value: null },\n\t\t\"u_skyColor\": { value: null },\n\t\t\"u_oceanColor\": { value: null },\n\t\t\"u_sunDirection\": { value: null },\n\t\t\"u_exposure\": { value: null }\n\t},\n\tvertexShader: [\n\t\t\"precision highp float;\",\n\n\t\t\"varying vec3 vPos;\",\n\t\t\"varying vec2 vUV;\",\n\n\t\t\"uniform mat4 u_projectionMatrix;\",\n\t\t\"uniform mat4 u_viewMatrix;\",\n\t\t\"uniform float u_size;\",\n\t\t\"uniform float u_geometrySize;\",\n\t\t\"uniform sampler2D u_displacementMap;\",\n\n\t\t\"void main (void) {\",\n\t\t\"\tvec3 newPos = position + texture2D(u_displacementMap, uv).rgb * (u_geometrySize / u_size);\",\n\t\t\"\tvPos = newPos;\",\n\t\t\"\tvUV = uv;\",\n\t\t\"\tgl_Position = u_projectionMatrix * u_viewMatrix * vec4(newPos, 1.0);\",\n\t\t\"}\"\n\t].join( \"\\n\" ),\n\tfragmentShader: [\n\t\t\"precision highp float;\",\n\n\t\t\"varying vec3 vPos;\",\n\t\t\"varying vec2 vUV;\",\n\n\t\t\"uniform sampler2D u_displacementMap;\",\n\t\t\"uniform sampler2D u_normalMap;\",\n\t\t\"uniform vec3 u_cameraPosition;\",\n\t\t\"uniform vec3 u_oceanColor;\",\n\t\t\"uniform vec3 u_skyColor;\",\n\t\t\"uniform vec3 u_sunDirection;\",\n\t\t\"uniform float u_exposure;\",\n\n\t\t\"vec3 hdr (vec3 color, float exposure) {\",\n\t\t\"\treturn 1.0 - exp(-color * exposure);\",\n\t\t\"}\",\n\n\t\t\"void main (void) {\",\n\t\t\"\tvec3 normal = texture2D(u_normalMap, vUV).rgb;\",\n\n\t\t\"\tvec3 view = normalize(u_cameraPosition - vPos);\",\n\t\t\"\tfloat fresnel = 0.02 + 0.98 * pow(1.0 - dot(normal, view), 5.0);\",\n\t\t\"\tvec3 sky = fresnel * u_skyColor;\",\n\n\t\t\"\tfloat diffuse = clamp(dot(normal, normalize(u_sunDirection)), 0.0, 1.0);\",\n\t\t\"\tvec3 water = (1.0 - fresnel) * u_oceanColor * u_skyColor * diffuse;\",\n\n\t\t\"\tvec3 color = sky + water;\",\n\n\t\t\"\tgl_FragColor = vec4(hdr(color, u_exposure), 1.0);\",\n\t\t\"}\"\n\t].join( \"\\n\" )\n};\n"]}