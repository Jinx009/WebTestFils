{"version":3,"sources":["FreiChenShader.js"],"names":[],"mappings":"AAAA,QAAQ,IAAR,CAAc,+SAAd;AACA;;;;;;;AAOA,MAAM,cAAN,GAAuB;;AAEtB,WAAU;;AAET,cAAY,EAAE,OAAO,IAAT,EAFH;AAGT,YAAU,EAAE,OAAO,IAAI,MAAM,OAAV,CAAmB,GAAnB,EAAwB,GAAxB,CAAT;AAHD,EAFY;;AAQtB,eAAc,CAEb,mBAFa,EAIb,eAJa,EAMb,YANa,EAOb,4EAPa,EASb,GATa,EAWZ,IAXY,CAWN,IAXM,CARQ;;AAqBtB,iBAAgB,CAEf,6BAFe,EAGf,mBAHe,EAKf,sBALe,EAOf,oDAPe,EAUf,YAVe;;AAYf;;AAEA,gIAde,EAef,+HAfe,EAgBf,+HAhBe,EAiBf,+HAjBe,EAkBf,8DAlBe,EAmBf,8DAnBe,EAoBf,iNApBe,EAqBf,iNArBe,EAsBf,6MAtBe,EAwBf,iBAxBe,EAyBf,GAzBe,EA2Bf,aA3Be,EA4Bf,aA5Be,EA6Bf,aA7Be,EA8Bf,aA9Be,EA+Bf,aA/Be,EAgCf,aAhCe,EAiCf,aAjCe,EAkCf,aAlCe,EAmCf,aAnCe,EAqCf,UArCe,EAsCf,gBAtCe,EAuCf,eAvCe;;AAyCf;AACA,mCA1Ce,EA2Cf,mCA3Ce,EA4Cf,wEA5Ce,EA6Cf,wCA7Ce,EA8Cf,KA9Ce,EA+Cf,IA/Ce;;AAiDf;AACA,6BAlDe,EAmDf,6EAnDe,EAoDf,uBApDe,EAqDf,IArDe,EAuDf,mDAvDe,EAwDf,kEAxDe,EA0Df,6CA1De,EA2Df,GA3De,EA6Dd,IA7Dc,CA6DR,IA7DQ;AArBM,CAAvB","file":"FreiChenShader-compiled.js","sourcesContent":["console.warn( \"THREE.FreiChenShader: As part of the transition to ES6 Modules, the files in 'examples/js' were deprecated in May 2020 (r117) and will be deleted in December 2020 (r124). You can find more information about developing using ES6 Modules in https://threejs.org/docs/#manual/en/introduction/Installation.\" );\n/**\n * Edge Detection Shader using Frei-Chen filter\n * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\n *\n * aspect: vec2 of (1/width, 1/height)\n */\n\nTHREE.FreiChenShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"aspect\": { value: new THREE.Vector2( 512, 512 ) }\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv;\",\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"uniform vec2 aspect;\",\n\n\t\t\"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\",\n\n\n\t\t\"mat3 G[9];\",\n\n\t\t// hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\n\n\t\t\"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\",\n\t\t\"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\",\n\t\t\"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\",\n\t\t\"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\",\n\t\t\"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\",\n\t\t\"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\",\n\t\t\"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\",\n\t\t\"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\",\n\t\t\"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\",\n\n\t\t\"void main(void)\",\n\t\t\"{\",\n\n\t\t\"\tG[0] = g0,\",\n\t\t\"\tG[1] = g1,\",\n\t\t\"\tG[2] = g2,\",\n\t\t\"\tG[3] = g3,\",\n\t\t\"\tG[4] = g4,\",\n\t\t\"\tG[5] = g5,\",\n\t\t\"\tG[6] = g6,\",\n\t\t\"\tG[7] = g7,\",\n\t\t\"\tG[8] = g8;\",\n\n\t\t\"\tmat3 I;\",\n\t\t\"\tfloat cnv[9];\",\n\t\t\"\tvec3 sample;\",\n\n\t\t/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n\t\t\"\tfor (float i=0.0; i<3.0; i++) {\",\n\t\t\"\t\tfor (float j=0.0; j<3.0; j++) {\",\n\t\t\"\t\t\tsample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\",\n\t\t\"\t\t\tI[int(i)][int(j)] = length(sample);\",\n\t\t\"\t\t}\",\n\t\t\"\t}\",\n\n\t\t/* calculate the convolution values for all the masks */\n\t\t\"\tfor (int i=0; i<9; i++) {\",\n\t\t\"\t\tfloat dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\",\n\t\t\"\t\tcnv[i] = dp3 * dp3;\",\n\t\t\"\t}\",\n\n\t\t\"\tfloat M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\",\n\t\t\"\tfloat S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\",\n\n\t\t\"\tgl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);\",\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n};\n"]}