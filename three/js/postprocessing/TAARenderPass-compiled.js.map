{"version":3,"sources":["TAARenderPass.js"],"names":[],"mappings":"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","file":"TAARenderPass-compiled.js","sourcesContent":["console.warn( \"THREE.TAARenderPass: As part of the transition to ES6 Modules, the files in 'examples/js' were deprecated in May 2020 (r117) and will be deleted in December 2020 (r124). You can find more information about developing using ES6 Modules in https://threejs.org/docs/#manual/en/introduction/Installation.\" );\n/**\n *\n * Temporal Anti-Aliasing Render Pass\n *\n * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.\n *\n * References:\n *\n * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.\n *\n */\n\nTHREE.TAARenderPass = function ( scene, camera, clearColor, clearAlpha ) {\n\n\tif ( THREE.SSAARenderPass === undefined ) {\n\n\t\tconsole.error( \"THREE.TAARenderPass relies on THREE.SSAARenderPass\" );\n\n\t}\n\n\tTHREE.SSAARenderPass.call( this, scene, camera, clearColor, clearAlpha );\n\n\tthis.sampleLevel = 0;\n\tthis.accumulate = false;\n\n};\n\nTHREE.TAARenderPass.JitterVectors = THREE.SSAARenderPass.JitterVectors;\n\nTHREE.TAARenderPass.prototype = Object.assign( Object.create( THREE.SSAARenderPass.prototype ), {\n\n\tconstructor: THREE.TAARenderPass,\n\n\trender: function ( renderer, writeBuffer, readBuffer, deltaTime ) {\n\n\t\tif ( ! this.accumulate ) {\n\n\t\t\tTHREE.SSAARenderPass.prototype.render.call( this, renderer, writeBuffer, readBuffer, deltaTime );\n\n\t\t\tthis.accumulateIndex = - 1;\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar jitterOffsets = THREE.TAARenderPass.JitterVectors[ 5 ];\n\n\t\tif ( ! this.sampleRenderTarget ) {\n\n\t\t\tthis.sampleRenderTarget = new THREE.WebGLRenderTarget( readBuffer.width, readBuffer.height, this.params );\n\t\t\tthis.sampleRenderTarget.texture.name = \"TAARenderPass.sample\";\n\n\t\t}\n\n\t\tif ( ! this.holdRenderTarget ) {\n\n\t\t\tthis.holdRenderTarget = new THREE.WebGLRenderTarget( readBuffer.width, readBuffer.height, this.params );\n\t\t\tthis.holdRenderTarget.texture.name = \"TAARenderPass.hold\";\n\n\t\t}\n\n\t\tif ( this.accumulate && this.accumulateIndex === - 1 ) {\n\n\t\t\tTHREE.SSAARenderPass.prototype.render.call( this, renderer, this.holdRenderTarget, readBuffer, deltaTime );\n\n\t\t\tthis.accumulateIndex = 0;\n\n\t\t}\n\n\t\tvar autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tvar sampleWeight = 1.0 / ( jitterOffsets.length );\n\n\t\tif ( this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length ) {\n\n\t\t\tthis.copyUniforms[ \"opacity\" ].value = sampleWeight;\n\t\t\tthis.copyUniforms[ \"tDiffuse\" ].value = writeBuffer.texture;\n\n\t\t\t// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\t\t\tvar numSamplesPerFrame = Math.pow( 2, this.sampleLevel );\n\t\t\tfor ( var i = 0; i < numSamplesPerFrame; i ++ ) {\n\n\t\t\t\tvar j = this.accumulateIndex;\n\t\t\t\tvar jitterOffset = jitterOffsets[ j ];\n\n\t\t\t\tif ( this.camera.setViewOffset ) {\n\n\t\t\t\t\tthis.camera.setViewOffset( readBuffer.width, readBuffer.height,\n\t\t\t\t\t\tjitterOffset[ 0 ] * 0.0625, jitterOffset[ 1 ] * 0.0625, // 0.0625 = 1 / 16\n\t\t\t\t\t\treadBuffer.width, readBuffer.height );\n\n\t\t\t\t}\n\n\t\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\t\trenderer.clear();\n\t\t\t\trenderer.render( this.scene, this.camera );\n\n\t\t\t\trenderer.setRenderTarget( this.sampleRenderTarget );\n\t\t\t\tif ( this.accumulateIndex === 0 ) renderer.clear();\n\t\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t\tthis.accumulateIndex ++;\n\n\t\t\t\tif ( this.accumulateIndex >= jitterOffsets.length ) break;\n\n\t\t\t}\n\n\t\t\tif ( this.camera.clearViewOffset ) this.camera.clearViewOffset();\n\n\t\t}\n\n\t\tvar accumulationWeight = this.accumulateIndex * sampleWeight;\n\n\t\tif ( accumulationWeight > 0 ) {\n\n\t\t\tthis.copyUniforms[ \"opacity\" ].value = 1.0;\n\t\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.sampleRenderTarget.texture;\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\tif ( accumulationWeight < 1.0 ) {\n\n\t\t\tthis.copyUniforms[ \"opacity\" ].value = 1.0 - accumulationWeight;\n\t\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.holdRenderTarget.texture;\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\tif ( accumulationWeight === 0 ) renderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\n\t}\n\n} );\n"]}