{"version":3,"sources":["SubdivisionModifier.js"],"names":[],"mappings":"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","file":"SubdivisionModifier-compiled.js","sourcesContent":["console.warn( \"THREE.SubdivisionModifier: As part of the transition to ES6 Modules, the files in 'examples/js' were deprecated in May 2020 (r117) and will be deleted in December 2020 (r124). You can find more information about developing using ES6 Modules in https://threejs.org/docs/#manual/en/introduction/Installation.\" );\n/**\n *\tSubdivision Geometry Modifier\n *\t\tusing Loop Subdivision Scheme\n *\n *\tReferences:\n *\t\thttp://graphics.stanford.edu/~mdfisher/subdivision.html\n *\t\thttp://www.holmes3d.net/graphics/subdivision/\n *\t\thttp://www.cs.rutgers.edu/~decarlo/readings/subdiv-sg00c.pdf\n *\n *\tKnown Issues:\n *\t\t- currently doesn't handle \"Sharp Edges\"\n */\n\nTHREE.SubdivisionModifier = function ( subdivisions ) {\n\n\tthis.subdivisions = ( subdivisions === undefined ) ? 1 : subdivisions;\n\n};\n\n// Applies the \"modify\" pattern\nTHREE.SubdivisionModifier.prototype.modify = function ( geometry ) {\n\n\tif ( geometry.isBufferGeometry ) {\n\n\t\tgeometry = new THREE.Geometry().fromBufferGeometry( geometry );\n\n\t} else {\n\n\t\tgeometry = geometry.clone();\n\n\t}\n\n\tgeometry.mergeVertices();\n\n\tvar repeats = this.subdivisions;\n\n\twhile ( repeats -- > 0 ) {\n\n\t\tthis.smooth( geometry );\n\n\t}\n\n\tgeometry.computeFaceNormals();\n\tgeometry.computeVertexNormals();\n\n\treturn geometry;\n\n};\n\n( function () {\n\n\t// Some constants\n\tvar ABC = [ 'a', 'b', 'c' ];\n\n\n\tfunction getEdge( a, b, map ) {\n\n\t\tvar vertexIndexA = Math.min( a, b );\n\t\tvar vertexIndexB = Math.max( a, b );\n\n\t\tvar key = vertexIndexA + \"_\" + vertexIndexB;\n\n\t\treturn map[ key ];\n\n\t}\n\n\n\tfunction processEdge( a, b, vertices, map, face, metaVertices ) {\n\n\t\tvar vertexIndexA = Math.min( a, b );\n\t\tvar vertexIndexB = Math.max( a, b );\n\n\t\tvar key = vertexIndexA + \"_\" + vertexIndexB;\n\n\t\tvar edge;\n\n\t\tif ( key in map ) {\n\n\t\t\tedge = map[ key ];\n\n\t\t} else {\n\n\t\t\tvar vertexA = vertices[ vertexIndexA ];\n\t\t\tvar vertexB = vertices[ vertexIndexB ];\n\n\t\t\tedge = {\n\n\t\t\t\ta: vertexA, // pointer reference\n\t\t\t\tb: vertexB,\n\t\t\t\tnewEdge: null,\n\t\t\t\t// aIndex: a, // numbered reference\n\t\t\t\t// bIndex: b,\n\t\t\t\tfaces: [] // pointers to face\n\n\t\t\t};\n\n\t\t\tmap[ key ] = edge;\n\n\t\t}\n\n\t\tedge.faces.push( face );\n\n\t\tmetaVertices[ a ].edges.push( edge );\n\t\tmetaVertices[ b ].edges.push( edge );\n\n\n\t}\n\n\tfunction generateLookups( vertices, faces, metaVertices, edges ) {\n\n\t\tvar i, il, face;\n\n\t\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tmetaVertices[ i ] = { edges: [] };\n\n\t\t}\n\n\t\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tface = faces[ i ];\n\n\t\t\tprocessEdge( face.a, face.b, vertices, edges, face, metaVertices );\n\t\t\tprocessEdge( face.b, face.c, vertices, edges, face, metaVertices );\n\t\t\tprocessEdge( face.c, face.a, vertices, edges, face, metaVertices );\n\n\t\t}\n\n\t}\n\n\tfunction newFace( newFaces, a, b, c, materialIndex ) {\n\n\t\tnewFaces.push( new THREE.Face3( a, b, c, undefined, undefined, materialIndex ) );\n\n\t}\n\n\tfunction midpoint( a, b ) {\n\n\t\treturn ( Math.abs( b - a ) / 2 ) + Math.min( a, b );\n\n\t}\n\n\tfunction newUv( newUvs, a, b, c ) {\n\n\t\tnewUvs.push( [ a.clone(), b.clone(), c.clone() ] );\n\n\t}\n\n\t/////////////////////////////\n\n\t// Performs one iteration of Subdivision\n\tTHREE.SubdivisionModifier.prototype.smooth = function ( geometry ) {\n\n\t\tvar tmp = new THREE.Vector3();\n\n\t\tvar oldVertices, oldFaces, oldUvs;\n\t\tvar newVertices, newFaces, newUVs = [];\n\n\t\tvar n, i, il, j, k;\n\t\tvar metaVertices, sourceEdges;\n\n\t\t// new stuff.\n\t\tvar sourceEdges, newEdgeVertices, newSourceVertices;\n\n\t\toldVertices = geometry.vertices; // { x, y, z}\n\t\toldFaces = geometry.faces; // { a: oldVertex1, b: oldVertex2, c: oldVertex3 }\n\t\toldUvs = geometry.faceVertexUvs;\n\n\t\tvar hasUvs = oldUvs[ 0 ] !== undefined && oldUvs[ 0 ].length > 0;\n\n\t\tif ( hasUvs ) {\n\n\t\t\tfor ( var j = 0; j < oldUvs.length; j ++ ) {\n\n\t\t\t\tnewUVs.push( [] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/******************************************************\n\t\t *\n\t\t * Step 0: Preprocess Geometry to Generate edges Lookup\n\t\t *\n\t\t *******************************************************/\n\n\t\tmetaVertices = new Array( oldVertices.length );\n\t\tsourceEdges = {}; // Edge => { oldVertex1, oldVertex2, faces[]  }\n\n\t\tgenerateLookups( oldVertices, oldFaces, metaVertices, sourceEdges );\n\n\n\t\t/******************************************************\n\t\t *\n\t\t *\tStep 1.\n\t\t *\tFor each edge, create a new Edge Vertex,\n\t\t *\tthen position it.\n\t\t *\n\t\t *******************************************************/\n\n\t\tnewEdgeVertices = [];\n\t\tvar other, currentEdge, newEdge, face;\n\t\tvar edgeVertexWeight, adjacentVertexWeight, connectedFaces;\n\n\t\tfor ( i in sourceEdges ) {\n\n\t\t\tcurrentEdge = sourceEdges[ i ];\n\t\t\tnewEdge = new THREE.Vector3();\n\n\t\t\tedgeVertexWeight = 3 / 8;\n\t\t\tadjacentVertexWeight = 1 / 8;\n\n\t\t\tconnectedFaces = currentEdge.faces.length;\n\n\t\t\t// check how many linked faces. 2 should be correct.\n\t\t\tif ( connectedFaces != 2 ) {\n\n\t\t\t\t// if length is not 2, handle condition\n\t\t\t\tedgeVertexWeight = 0.5;\n\t\t\t\tadjacentVertexWeight = 0;\n\n\t\t\t\tif ( connectedFaces != 1 ) {\n\n\t\t\t\t\t// console.warn( 'Subdivision Modifier: Number of connected faces != 2, is: ', connectedFaces, currentEdge );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewEdge.addVectors( currentEdge.a, currentEdge.b ).multiplyScalar( edgeVertexWeight );\n\n\t\t\ttmp.set( 0, 0, 0 );\n\n\t\t\tfor ( j = 0; j < connectedFaces; j ++ ) {\n\n\t\t\t\tface = currentEdge.faces[ j ];\n\n\t\t\t\tfor ( k = 0; k < 3; k ++ ) {\n\n\t\t\t\t\tother = oldVertices[ face[ ABC[ k ] ] ];\n\t\t\t\t\tif ( other !== currentEdge.a && other !== currentEdge.b ) break;\n\n\t\t\t\t}\n\n\t\t\t\ttmp.add( other );\n\n\t\t\t}\n\n\t\t\ttmp.multiplyScalar( adjacentVertexWeight );\n\t\t\tnewEdge.add( tmp );\n\n\t\t\tcurrentEdge.newEdge = newEdgeVertices.length;\n\t\t\tnewEdgeVertices.push( newEdge );\n\n\t\t\t// console.log(currentEdge, newEdge);\n\n\t\t}\n\n\t\t/******************************************************\n\t\t *\n\t\t *\tStep 2.\n\t\t *\tReposition each source vertices.\n\t\t *\n\t\t *******************************************************/\n\n\t\tvar beta, sourceVertexWeight, connectingVertexWeight;\n\t\tvar connectingEdge, connectingEdges, oldVertex, newSourceVertex;\n\t\tnewSourceVertices = [];\n\n\t\tfor ( i = 0, il = oldVertices.length; i < il; i ++ ) {\n\n\t\t\toldVertex = oldVertices[ i ];\n\n\t\t\t// find all connecting edges (using lookupTable)\n\t\t\tconnectingEdges = metaVertices[ i ].edges;\n\t\t\tn = connectingEdges.length;\n\n\t\t\tif ( n == 3 ) {\n\n\t\t\t\tbeta = 3 / 16;\n\n\t\t\t} else if ( n > 3 ) {\n\n\t\t\t\tbeta = 3 / ( 8 * n ); // Warren's modified formula\n\n\t\t\t}\n\n\t\t\t// Loop's original beta formula\n\t\t\t// beta = 1 / n * ( 5/8 - Math.pow( 3/8 + 1/4 * Math.cos( 2 * Math. PI / n ), 2) );\n\n\t\t\tsourceVertexWeight = 1 - n * beta;\n\t\t\tconnectingVertexWeight = beta;\n\n\t\t\tif ( n <= 2 ) {\n\n\t\t\t\t// crease and boundary rules\n\t\t\t\t// console.warn('crease and boundary rules');\n\n\t\t\t\tif ( n == 2 ) {\n\n\t\t\t\t\t// console.warn( '2 connecting edges', connectingEdges );\n\t\t\t\t\tsourceVertexWeight = 3 / 4;\n\t\t\t\t\tconnectingVertexWeight = 1 / 8;\n\n\t\t\t\t\t// sourceVertexWeight = 1;\n\t\t\t\t\t// connectingVertexWeight = 0;\n\n\t\t\t\t} else if ( n == 1 ) {\n\n\t\t\t\t\t// console.warn( 'only 1 connecting edge' );\n\n\t\t\t\t} else if ( n == 0 ) {\n\n\t\t\t\t\t// console.warn( '0 connecting edges' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewSourceVertex = oldVertex.clone().multiplyScalar( sourceVertexWeight );\n\n\t\t\ttmp.set( 0, 0, 0 );\n\n\t\t\tfor ( j = 0; j < n; j ++ ) {\n\n\t\t\t\tconnectingEdge = connectingEdges[ j ];\n\t\t\t\tother = connectingEdge.a !== oldVertex ? connectingEdge.a : connectingEdge.b;\n\t\t\t\ttmp.add( other );\n\n\t\t\t}\n\n\t\t\ttmp.multiplyScalar( connectingVertexWeight );\n\t\t\tnewSourceVertex.add( tmp );\n\n\t\t\tnewSourceVertices.push( newSourceVertex );\n\n\t\t}\n\n\n\t\t/******************************************************\n\t\t *\n\t\t *\tStep 3.\n\t\t *\tGenerate Faces between source vertices\n\t\t *\tand edge vertices.\n\t\t *\n\t\t *******************************************************/\n\n\t\tnewVertices = newSourceVertices.concat( newEdgeVertices );\n\t\tvar sl = newSourceVertices.length, edge1, edge2, edge3;\n\t\tnewFaces = [];\n\n\t\tvar uv, x0, x1, x2;\n\t\tvar x3 = new THREE.Vector2();\n\t\tvar x4 = new THREE.Vector2();\n\t\tvar x5 = new THREE.Vector2();\n\n\t\tfor ( i = 0, il = oldFaces.length; i < il; i ++ ) {\n\n\t\t\tface = oldFaces[ i ];\n\n\t\t\t// find the 3 new edges vertex of each old face\n\n\t\t\tedge1 = getEdge( face.a, face.b, sourceEdges ).newEdge + sl;\n\t\t\tedge2 = getEdge( face.b, face.c, sourceEdges ).newEdge + sl;\n\t\t\tedge3 = getEdge( face.c, face.a, sourceEdges ).newEdge + sl;\n\n\t\t\t// create 4 faces.\n\n\t\t\tnewFace( newFaces, edge1, edge2, edge3, face.materialIndex );\n\t\t\tnewFace( newFaces, face.a, edge1, edge3, face.materialIndex );\n\t\t\tnewFace( newFaces, face.b, edge2, edge1, face.materialIndex );\n\t\t\tnewFace( newFaces, face.c, edge3, edge2, face.materialIndex );\n\n\t\t\t// create 4 new uv's\n\n\t\t\tif ( hasUvs ) {\n\n\t\t\t\tfor ( var j = 0; j < oldUvs.length; j ++ ) {\n\n\t\t\t\t\tuv = oldUvs[ j ][ i ];\n\n\t\t\t\t\tx0 = uv[ 0 ];\n\t\t\t\t\tx1 = uv[ 1 ];\n\t\t\t\t\tx2 = uv[ 2 ];\n\n\t\t\t\t\tx3.set( midpoint( x0.x, x1.x ), midpoint( x0.y, x1.y ) );\n\t\t\t\t\tx4.set( midpoint( x1.x, x2.x ), midpoint( x1.y, x2.y ) );\n\t\t\t\t\tx5.set( midpoint( x0.x, x2.x ), midpoint( x0.y, x2.y ) );\n\n\t\t\t\t\tnewUv( newUVs[ j ], x3, x4, x5 );\n\t\t\t\t\tnewUv( newUVs[ j ], x0, x3, x5 );\n\n\t\t\t\t\tnewUv( newUVs[ j ], x1, x4, x3 );\n\t\t\t\t\tnewUv( newUVs[ j ], x2, x5, x4 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Overwrite old arrays\n\t\tgeometry.vertices = newVertices;\n\t\tgeometry.faces = newFaces;\n\t\tif ( hasUvs ) geometry.faceVertexUvs = newUVs;\n\n\t\t// console.log('done');\n\n\t};\n\n} )();\n"]}