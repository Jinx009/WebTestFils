{"version":3,"sources":["GPUComputationRenderer.js"],"names":[],"mappings":"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","file":"GPUComputationRenderer-compiled.js","sourcesContent":["console.warn( \"THREE.GPUComputationRenderer: As part of the transition to ES6 Modules, the files in 'examples/js' were deprecated in May 2020 (r117) and will be deleted in December 2020 (r124). You can find more information about developing using ES6 Modules in https://threejs.org/docs/#manual/en/introduction/Installation.\" );\n/**\n * GPUComputationRenderer, based on SimulationRenderer by zz85\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel)\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n *\n * -------------\n *\n * Basic use:\n *\n * // Initialization...\n *\n * // Create computation renderer\n * var gpuCompute = new THREE.GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * var pos0 = gpuCompute.createTexture();\n * var vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * var velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\n * var posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * var error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n  * }\n *\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n *\n * -------------\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * var inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * var myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * var outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n *\n *\n *\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {WebGLRenderer} renderer The renderer\n  */\n\nTHREE.GPUComputationRenderer = function ( sizeX, sizeY, renderer ) {\n\n\tthis.variables = [];\n\n\tthis.currentTextureIndex = 0;\n\n\tvar dataType = THREE.FloatType;\n\n\tvar scene = new THREE.Scene();\n\n\tvar camera = new THREE.Camera();\n\tcamera.position.z = 1;\n\n\tvar passThruUniforms = {\n\t\tpassThruTexture: { value: null }\n\t};\n\n\tvar passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\n\n\tvar mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), passThruShader );\n\tscene.add( mesh );\n\n\n\tthis.setDataType = function ( type ) {\n\n\t\tdataType = type;\n\t\treturn this;\n\n\t};\n\n\tthis.addVariable = function ( variableName, computeFragmentShader, initialValueTexture ) {\n\n\t\tvar material = this.createShaderMaterial( computeFragmentShader );\n\n\t\tvar variable = {\n\t\t\tname: variableName,\n\t\t\tinitialValueTexture: initialValueTexture,\n\t\t\tmaterial: material,\n\t\t\tdependencies: null,\n\t\t\trenderTargets: [],\n\t\t\twrapS: null,\n\t\t\twrapT: null,\n\t\t\tminFilter: THREE.NearestFilter,\n\t\t\tmagFilter: THREE.NearestFilter\n\t\t};\n\n\t\tthis.variables.push( variable );\n\n\t\treturn variable;\n\n\t};\n\n\tthis.setVariableDependencies = function ( variable, dependencies ) {\n\n\t\tvariable.dependencies = dependencies;\n\n\t};\n\n\tthis.init = function () {\n\n\t\tif ( ! renderer.capabilities.isWebGL2 &&\n\t\t\t ! renderer.extensions.get( \"OES_texture_float\" ) ) {\n\n\t\t\treturn \"No OES_texture_float support for float textures.\";\n\n\t\t}\n\n\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\n\n\t\t\treturn \"No support for vertex shader textures.\";\n\n\t\t}\n\n\t\tfor ( var i = 0; i < this.variables.length; i ++ ) {\n\n\t\t\tvar variable = this.variables[ i ];\n\n\t\t\t// Creates rendertargets and initialize them with input texture\n\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\n\n\t\t\t// Adds dependencies uniforms to the ShaderMaterial\n\t\t\tvar material = variable.material;\n\t\t\tvar uniforms = material.uniforms;\n\n\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\tfor ( var d = 0; d < variable.dependencies.length; d ++ ) {\n\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\n\n\t\t\t\t\tif ( depVar.name !== variable.name ) {\n\n\t\t\t\t\t\t// Checks if variable exists\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\tfor ( var j = 0; j < this.variables.length; j ++ ) {\n\n\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\n\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( ! found ) {\n\n\t\t\t\t\t\t\treturn \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\n\n\t\t\t\t\tmaterial.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.currentTextureIndex = 0;\n\n\t\treturn null;\n\n\t};\n\n\tthis.compute = function () {\n\n\t\tvar currentTextureIndex = this.currentTextureIndex;\n\t\tvar nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n\t\tfor ( var i = 0, il = this.variables.length; i < il; i ++ ) {\n\n\t\t\tvar variable = this.variables[ i ];\n\n\t\t\t// Sets texture dependencies uniforms\n\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\tvar uniforms = variable.material.uniforms;\n\t\t\t\tfor ( var d = 0, dl = variable.dependencies.length; d < dl; d ++ ) {\n\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\n\n\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Performs the computation for this variable\n\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\n\n\t\t}\n\n\t\tthis.currentTextureIndex = nextTextureIndex;\n\n\t};\n\n\tthis.getCurrentRenderTarget = function ( variable ) {\n\n\t\treturn variable.renderTargets[ this.currentTextureIndex ];\n\n\t};\n\n\tthis.getAlternateRenderTarget = function ( variable ) {\n\n\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\n\n\t};\n\n\tfunction addResolutionDefine( materialShader ) {\n\n\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + \" )\";\n\n\t}\n\n\tthis.addResolutionDefine = addResolutionDefine;\n\n\n\t// The following functions can be used to compute things manually\n\n\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\n\n\t\tuniforms = uniforms || {};\n\n\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: uniforms,\n\t\t\tvertexShader: getPassThroughVertexShader(),\n\t\t\tfragmentShader: computeFragmentShader\n\t\t} );\n\n\t\taddResolutionDefine( material );\n\n\t\treturn material;\n\n\t}\n\n\tthis.createShaderMaterial = createShaderMaterial;\n\n\tthis.createRenderTarget = function ( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\n\n\t\tsizeXTexture = sizeXTexture || sizeX;\n\t\tsizeYTexture = sizeYTexture || sizeY;\n\n\t\twrapS = wrapS || THREE.ClampToEdgeWrapping;\n\t\twrapT = wrapT || THREE.ClampToEdgeWrapping;\n\n\t\tminFilter = minFilter || THREE.NearestFilter;\n\t\tmagFilter = magFilter || THREE.NearestFilter;\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget( sizeXTexture, sizeYTexture, {\n\t\t\twrapS: wrapS,\n\t\t\twrapT: wrapT,\n\t\t\tminFilter: minFilter,\n\t\t\tmagFilter: magFilter,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\ttype: dataType,\n\t\t\tdepthBuffer: false\n\t\t} );\n\n\t\treturn renderTarget;\n\n\t};\n\n\tthis.createTexture = function () {\n\n\t\tvar data = new Float32Array( sizeX * sizeY * 4 );\n\t\treturn new THREE.DataTexture( data, sizeX, sizeY, THREE.RGBAFormat, THREE.FloatType );\n\n\t};\n\n\tthis.renderTexture = function ( input, output ) {\n\n\t\t// Takes a texture, and render out in rendertarget\n\t\t// input = Texture\n\t\t// output = RenderTarget\n\n\t\tpassThruUniforms.passThruTexture.value = input;\n\n\t\tthis.doRenderTarget( passThruShader, output );\n\n\t\tpassThruUniforms.passThruTexture.value = null;\n\n\t};\n\n\tthis.doRenderTarget = function ( material, output ) {\n\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\tmesh.material = material;\n\t\trenderer.setRenderTarget( output );\n\t\trenderer.render( scene, camera );\n\t\tmesh.material = passThruShader;\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t};\n\n\t// Shaders\n\n\tfunction getPassThroughVertexShader() {\n\n\t\treturn\t\"void main()\t{\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tgl_Position = vec4( position, 1.0 );\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"}\\n\";\n\n\t}\n\n\tfunction getPassThroughFragmentShader() {\n\n\t\treturn\t\"uniform sampler2D passThruTexture;\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"void main() {\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tgl_FragColor = texture2D( passThruTexture, uv );\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"}\\n\";\n\n\t}\n\n};\n"]}