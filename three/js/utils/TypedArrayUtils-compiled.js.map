{"version":3,"sources":["TypedArrayUtils.js"],"names":[],"mappings":"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","file":"TypedArrayUtils-compiled.js","sourcesContent":["console.warn( \"THREE.TypedArrayUtils: As part of the transition to ES6 Modules, the files in 'examples/js' were deprecated in May 2020 (r117) and will be deleted in December 2020 (r124). You can find more information about developing using ES6 Modules in https://threejs.org/docs/#manual/en/introduction/Installation.\" );\n\nTHREE.TypedArrayUtils = {};\n\n/**\n * In-place quicksort for typed arrays (e.g. for Float32Array)\n * provides fast sorting\n * useful e.g. for a custom shader and/or BufferGeometry\n *\n * Complexity: http://bigocheatsheet.com/ see Quicksort\n *\n * Example:\n * points: [x, y, z, x, y, z, x, y, z, ...]\n * eleSize: 3 //because of (x, y, z)\n * orderElement: 0 //order according to x\n */\n\nTHREE.TypedArrayUtils.quicksortIP = function ( arr, eleSize, orderElement ) {\n\n\tvar stack = [];\n\tvar sp = - 1;\n\tvar left = 0;\n\tvar right = arr.length / eleSize - 1;\n\tvar tmp = 0.0, x = 0, y = 0;\n\n\tvar swapF = function ( a, b ) {\n\n\t\ta *= eleSize; b *= eleSize;\n\n\t\tfor ( y = 0; y < eleSize; y ++ ) {\n\n\t\t\ttmp = arr[ a + y ];\n\t\t\tarr[ a + y ] = arr[ b + y ];\n\t\t\tarr[ b + y ] = tmp;\n\n\t\t}\n\n\t};\n\n\tvar i, j, swap = new Float32Array( eleSize ), temp = new Float32Array( eleSize );\n\n\twhile ( true ) {\n\n\t\tif ( right - left <= 25 ) {\n\n\t\t\tfor ( j = left + 1; j <= right; j ++ ) {\n\n\t\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\n\n\t\t\t\t\tswap[ x ] = arr[ j * eleSize + x ];\n\n\t\t\t\t}\n\n\t\t\t\ti = j - 1;\n\n\t\t\t\twhile ( i >= left && arr[ i * eleSize + orderElement ] > swap[ orderElement ] ) {\n\n\t\t\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\n\n\t\t\t\t\t\tarr[ ( i + 1 ) * eleSize + x ] = arr[ i * eleSize + x ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\ti --;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\n\n\t\t\t\t\tarr[ ( i + 1 ) * eleSize + x ] = swap[ x ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( sp == - 1 ) break;\n\n\t\t\tright = stack[ sp -- ]; //?\n\t\t\tleft = stack[ sp -- ];\n\n\t\t} else {\n\n\t\t\tvar median = ( left + right ) >> 1;\n\n\t\t\ti = left + 1;\n\t\t\tj = right;\n\n\t\t\tswapF( median, i );\n\n\t\t\tif ( arr[ left * eleSize + orderElement ] > arr[ right * eleSize + orderElement ] ) {\n\n\t\t\t\tswapF( left, right );\n\n\t\t\t}\n\n\t\t\tif ( arr[ i * eleSize + orderElement ] > arr[ right * eleSize + orderElement ] ) {\n\n\t\t\t\tswapF( i, right );\n\n\t\t\t}\n\n\t\t\tif ( arr[ left * eleSize + orderElement ] > arr[ i * eleSize + orderElement ] ) {\n\n\t\t\t\tswapF( left, i );\n\n\t\t\t}\n\n\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\n\n\t\t\t\ttemp[ x ] = arr[ i * eleSize + x ];\n\n\t\t\t}\n\n\t\t\twhile ( true ) {\n\n\t\t\t\tdo i ++; while ( arr[ i * eleSize + orderElement ] < temp[ orderElement ] );\n\t\t\t\tdo j --; while ( arr[ j * eleSize + orderElement ] > temp[ orderElement ] );\n\n\t\t\t\tif ( j < i ) break;\n\n\t\t\t\tswapF( i, j );\n\n\t\t\t}\n\n\t\t\tfor ( x = 0; x < eleSize; x ++ ) {\n\n\t\t\t\tarr[ ( left + 1 ) * eleSize + x ] = arr[ j * eleSize + x ];\n\t\t\t\tarr[ j * eleSize + x ] = temp[ x ];\n\n\t\t\t}\n\n\t\t\tif ( right - i + 1 >= j - left ) {\n\n\t\t\t\tstack[ ++ sp ] = i;\n\t\t\t\tstack[ ++ sp ] = right;\n\t\t\t\tright = j - 1;\n\n\t\t\t} else {\n\n\t\t\t\tstack[ ++ sp ] = left;\n\t\t\t\tstack[ ++ sp ] = j - 1;\n\t\t\t\tleft = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn arr;\n\n};\n\n\n\n/**\n * k-d Tree for typed arrays (e.g. for Float32Array), in-place\n * provides fast nearest neighbour search\n * useful e.g. for a custom shader and/or BufferGeometry, saves tons of memory\n * has no insert and remove, only buildup and neares neighbour search\n *\n * Based on https://github.com/ubilabs/kd-tree-javascript by Ubilabs\n *\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n *\n * Requires typed array quicksort\n *\n * Example:\n * points: [x, y, z, x, y, z, x, y, z, ...]\n * metric: function(a, b){\treturn Math.pow(a[0] - b[0], 2) +  Math.pow(a[1] - b[1], 2) +  Math.pow(a[2] - b[2], 2); }  //Manhatten distance\n * eleSize: 3 //because of (x, y, z)\n *\n * Further information (including mathematical properties)\n * http://en.wikipedia.org/wiki/Binary_tree\n * http://en.wikipedia.org/wiki/K-d_tree\n *\n * If you want to further minimize memory usage, remove Node.depth and replace in search algorithm with a traversal to root node (see comments at THREE.TypedArrayUtils.Kdtree.prototype.Node)\n */\n\nTHREE.TypedArrayUtils.Kdtree = function ( points, metric, eleSize ) {\n\n\tvar scope = this;\n\n\tvar maxDepth = 0;\n\n\tvar getPointSet = function ( points, pos ) {\n\n\t\treturn points.subarray( pos * eleSize, pos * eleSize + eleSize );\n\n\t};\n\n\tfunction buildTree( points, depth, parent, pos ) {\n\n\t\tvar dim = depth % eleSize,\n\t\t\tmedian,\n\t\t\tnode,\n\t\t\tplength = points.length / eleSize;\n\n\t\tif ( depth > maxDepth ) maxDepth = depth;\n\n\t\tif ( plength === 0 ) return null;\n\t\tif ( plength === 1 ) {\n\n\t\t\treturn new scope.Node( getPointSet( points, 0 ), depth, parent, pos );\n\n\t\t}\n\n\t\tTHREE.TypedArrayUtils.quicksortIP( points, eleSize, dim );\n\n\t\tmedian = Math.floor( plength / 2 );\n\n\t\tnode = new scope.Node( getPointSet( points, median ), depth, parent, median + pos );\n\t\tnode.left = buildTree( points.subarray( 0, median * eleSize ), depth + 1, node, pos );\n\t\tnode.right = buildTree( points.subarray( ( median + 1 ) * eleSize, points.length ), depth + 1, node, pos + median + 1 );\n\n\t\treturn node;\n\n\t}\n\n\tthis.root = buildTree( points, 0, null, 0 );\n\n\tthis.getMaxDepth = function () {\n\n\t\treturn maxDepth;\n\n\t};\n\n\tthis.nearest = function ( point, maxNodes, maxDistance ) {\n\n\t\t /* point: array of size eleSize\n\t\t\tmaxNodes: max amount of nodes to return\n\t\t\tmaxDistance: maximum distance to point result nodes should have\n\t\t\tcondition (not implemented): function to test node before it's added to the result list, e.g. test for view frustum\n\t\t*/\n\n\t\tvar i,\n\t\t\tresult,\n\t\t\tbestNodes;\n\n\t\tbestNodes = new THREE.TypedArrayUtils.Kdtree.BinaryHeap(\n\n\t\t\tfunction ( e ) {\n\n\t\t\t\treturn - e[ 1 ];\n\n\t\t\t}\n\n\t\t);\n\n\t\tfunction nearestSearch( node ) {\n\n\t\t\tvar bestChild,\n\t\t\t\tdimension = node.depth % eleSize,\n\t\t\t\townDistance = metric( point, node.obj ),\n\t\t\t\tlinearDistance = 0,\n\t\t\t\totherChild,\n\t\t\t\ti,\n\t\t\t\tlinearPoint = [];\n\n\t\t\tfunction saveNode( node, distance ) {\n\n\t\t\t\tbestNodes.push( [ node, distance ] );\n\n\t\t\t\tif ( bestNodes.size() > maxNodes ) {\n\n\t\t\t\t\tbestNodes.pop();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( i = 0; i < eleSize; i += 1 ) {\n\n\t\t\t\tif ( i === node.depth % eleSize ) {\n\n\t\t\t\t\tlinearPoint[ i ] = point[ i ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tlinearPoint[ i ] = node.obj[ i ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlinearDistance = metric( linearPoint, node.obj );\n\n\t\t\t// if it's a leaf\n\n\t\t\tif ( node.right === null && node.left === null ) {\n\n\t\t\t\tif ( bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[ 1 ] ) {\n\n\t\t\t\t\tsaveNode( node, ownDistance );\n\n\t\t\t\t}\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( node.right === null ) {\n\n\t\t\t\tbestChild = node.left;\n\n\t\t\t} else if ( node.left === null ) {\n\n\t\t\t\tbestChild = node.right;\n\n\t\t\t} else {\n\n\t\t\t\tif ( point[ dimension ] < node.obj[ dimension ] ) {\n\n\t\t\t\t\tbestChild = node.left;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbestChild = node.right;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// recursive search\n\n\t\t\tnearestSearch( bestChild );\n\n\t\t\tif ( bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[ 1 ] ) {\n\n\t\t\t\tsaveNode( node, ownDistance );\n\n\t\t\t}\n\n\t\t\t// if there's still room or the current distance is nearer than the best distance\n\n\t\t\tif ( bestNodes.size() < maxNodes || Math.abs( linearDistance ) < bestNodes.peek()[ 1 ] ) {\n\n\t\t\t\tif ( bestChild === node.left ) {\n\n\t\t\t\t\totherChild = node.right;\n\n\t\t\t\t} else {\n\n\t\t\t\t\totherChild = node.left;\n\n\t\t\t\t}\n\n\t\t\t\tif ( otherChild !== null ) {\n\n\t\t\t\t\tnearestSearch( otherChild );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( maxDistance ) {\n\n\t\t\tfor ( i = 0; i < maxNodes; i += 1 ) {\n\n\t\t\t\tbestNodes.push( [ null, maxDistance ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tnearestSearch( scope.root );\n\n\t\tresult = [];\n\n\t\tfor ( i = 0; i < maxNodes; i += 1 ) {\n\n\t\t\tif ( bestNodes.content[ i ][ 0 ] ) {\n\n\t\t\t\tresult.push( [ bestNodes.content[ i ][ 0 ], bestNodes.content[ i ][ 1 ] ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t};\n\n};\n\n/**\n * If you need to free up additional memory and agree with an additional O( log n ) traversal time you can get rid of \"depth\" and \"pos\" in Node:\n * Depth can be easily done by adding 1 for every parent (care: root node has depth 0, not 1)\n * Pos is a bit tricky: Assuming the tree is balanced (which is the case when after we built it up), perform the following steps:\n *   By traversing to the root store the path e.g. in a bit pattern (01001011, 0 is left, 1 is right)\n *   From buildTree we know that \"median = Math.floor( plength / 2 );\", therefore for each bit...\n *     0: amountOfNodesRelevantForUs = Math.floor( (pamountOfNodesRelevantForUs - 1) / 2 );\n *     1: amountOfNodesRelevantForUs = Math.ceil( (pamountOfNodesRelevantForUs - 1) / 2 );\n *        pos += Math.floor( (pamountOfNodesRelevantForUs - 1) / 2 );\n *     when recursion done, we still need to add all left children of target node:\n *        pos += Math.floor( (pamountOfNodesRelevantForUs - 1) / 2 );\n *        and I think you need to +1 for the current position, not sure.. depends, try it out ^^\n *\n * I experienced that for 200'000 nodes you can get rid of 4 MB memory each, leading to 8 MB memory saved.\n */\nTHREE.TypedArrayUtils.Kdtree.prototype.Node = function ( obj, depth, parent, pos ) {\n\n\tthis.obj = obj;\n\tthis.left = null;\n\tthis.right = null;\n\tthis.parent = parent;\n\tthis.depth = depth;\n\tthis.pos = pos;\n\n};\n\n/**\n * Binary heap implementation\n */\n\nTHREE.TypedArrayUtils.Kdtree.BinaryHeap = function ( scoreFunction ) {\n\n\tthis.content = [];\n\tthis.scoreFunction = scoreFunction;\n\n};\n\nTHREE.TypedArrayUtils.Kdtree.BinaryHeap.prototype = {\n\n\tpush: function ( element ) {\n\n\t\t// Add the new element to the end of the array.\n\t\tthis.content.push( element );\n\n\t\t// Allow it to bubble up.\n\t\tthis.bubbleUp( this.content.length - 1 );\n\n\t},\n\n\tpop: function () {\n\n\t\t// Store the first element so we can return it later.\n\t\tvar result = this.content[ 0 ];\n\n\t\t// Get the element at the end of the array.\n\t\tvar end = this.content.pop();\n\n\t\t// If there are any elements left, put the end element at the\n\t\t// start, and let it sink down.\n\t\tif ( this.content.length > 0 ) {\n\n\t\t\tthis.content[ 0 ] = end;\n\t\t\tthis.sinkDown( 0 );\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tpeek: function () {\n\n\t\treturn this.content[ 0 ];\n\n\t},\n\n\tremove: function ( node ) {\n\n\t\tvar len = this.content.length;\n\n\t\t// To remove a value, we must search through the array to find it.\n\t\tfor ( var i = 0; i < len; i ++ ) {\n\n\t\t\tif ( this.content[ i ] == node ) {\n\n\t\t\t\t// When it is found, the process seen in 'pop' is repeated\n\t\t\t\t// to fill up the hole.\n\t\t\t\tvar end = this.content.pop();\n\n\t\t\t\tif ( i != len - 1 ) {\n\n\t\t\t\t\tthis.content[ i ] = end;\n\n\t\t\t\t\tif ( this.scoreFunction( end ) < this.scoreFunction( node ) ) {\n\n\t\t\t\t\t\tthis.bubbleUp( i );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.sinkDown( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthrow new Error( \"Node not found.\" );\n\n\t},\n\n\tsize: function () {\n\n\t\treturn this.content.length;\n\n\t},\n\n\tbubbleUp: function ( n ) {\n\n\t\t// Fetch the element that has to be moved.\n\t\tvar element = this.content[ n ];\n\n\t\t// When at 0, an element can not go up any further.\n\t\twhile ( n > 0 ) {\n\n\t\t\t// Compute the parent element's index, and fetch it.\n\t\t\tvar parentN = Math.floor( ( n + 1 ) / 2 ) - 1,\n\t\t\t\tparent = this.content[ parentN ];\n\n\t\t\t// Swap the elements if the parent is greater.\n\t\t\tif ( this.scoreFunction( element ) < this.scoreFunction( parent ) ) {\n\n\t\t\t\tthis.content[ parentN ] = element;\n\t\t\t\tthis.content[ n ] = parent;\n\n\t\t\t\t// Update 'n' to continue at the new position.\n\t\t\t\tn = parentN;\n\n\t\t\t} else {\n\n\t\t\t\t// Found a parent that is less, no need to move it further.\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tsinkDown: function ( n ) {\n\n\t\t// Look up the target element and its score.\n\t\tvar length = this.content.length,\n\t\t\telement = this.content[ n ],\n\t\t\telemScore = this.scoreFunction( element );\n\n\t\twhile ( true ) {\n\n\t\t\t// Compute the indices of the child elements.\n\t\t\tvar child2N = ( n + 1 ) * 2, child1N = child2N - 1;\n\n\t\t\t// This is used to store the new position of the element, if any.\n\t\t\tvar swap = null;\n\n\t\t\t// If the first child exists (is inside the array)...\n\t\t\tif ( child1N < length ) {\n\n\t\t\t\t// Look it up and compute its score.\n\t\t\t\tvar child1 = this.content[ child1N ],\n\t\t\t\t\tchild1Score = this.scoreFunction( child1 );\n\n\t\t\t\t// If the score is less than our element's, we need to swap.\n\t\t\t\tif ( child1Score < elemScore ) swap = child1N;\n\n\t\t\t}\n\n\t\t\t// Do the same checks for the other child.\n\t\t\tif ( child2N < length ) {\n\n\t\t\t\tvar child2 = this.content[ child2N ],\n\t\t\t\t\tchild2Score = this.scoreFunction( child2 );\n\n\t\t\t\tif ( child2Score < ( swap === null ? elemScore : child1Score ) ) swap = child2N;\n\n\t\t\t}\n\n\t\t\t// If the element needs to be moved, swap it, and continue.\n\t\t\tif ( swap !== null ) {\n\n\t\t\t\tthis.content[ n ] = this.content[ swap ];\n\t\t\t\tthis.content[ swap ] = element;\n\t\t\t\tn = swap;\n\n\t\t\t} else {\n\n\t\t\t\t// Otherwise, we are done.\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n"]}